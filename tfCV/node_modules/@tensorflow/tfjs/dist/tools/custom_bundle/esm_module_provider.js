"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A module provider to generate custom esm modules.
 */
exports.esmModuleProvider = {
    importCoreStr: function () {
        return "\nimport {registerKernel, registerGradient} from '@tensorflow/tfjs-core/dist/base';\nimport '@tensorflow/tfjs-core/dist/base_side_effects';\nexport * from '@tensorflow/tfjs-core/dist/base';\n  ";
    },
    importConverterStr: function () {
        return "export * from '@tensorflow/tfjs-converter';";
    },
    importBackendStr: function (backend) {
        var backendPkg = getBackendPath(backend);
        return "export * from '" + backendPkg + "/dist/base';";
    },
    importKernelStr: function (kernelName, backend) {
        // TODO(yassogba) validate whether the target file referenced by
        // importStatement exists and warn the user if it doesn't. That could happen
        // here or in an earlier validation phase that uses this function
        var backendPkg = getBackendPath(backend);
        var kernelConfigId = kernelName + "_" + backend;
        var importStatement = "import {" + kernelNameToVariableName(kernelName) + "Config as " + kernelConfigId + "} from '" + backendPkg + "/dist/kernels/" + kernelName + "';";
        return { importStatement: importStatement, kernelConfigId: kernelConfigId };
    },
    importGradientConfigStr: function (kernelName) {
        // TODO(yassogba) validate whether the target file referenced by
        // importStatement exists and warn the user if it doesn't. That could happen
        // here or in an earlier validation phase that uses this function
        var gradConfigId = kernelNameToVariableName(kernelName) + "GradConfig";
        var importStatement = "import {" + gradConfigId + "} from '@tensorflow/tfjs-core/dist/gradients/" + kernelName + "_grad';";
        return { importStatement: importStatement, gradConfigId: gradConfigId };
    },
    kernelToOpsMapPath: function () {
        return require.resolve('@tensorflow/tfjs-converter/metadata/kernel2op.json');
    },
    importOpForConverterStr: function (opSymbol) {
        var opFileName = opNameToFileName(opSymbol);
        return "export {" + opSymbol + "} from '@tensorflow/tfjs-core/dist/ops/" + opFileName + "';";
    },
    importNamespacedOpsForConverterStr: function (namespace, opSymbols) {
        var result = [];
        for (var _i = 0, opSymbols_1 = opSymbols; _i < opSymbols_1.length; _i++) {
            var opSymbol = opSymbols_1[_i];
            var opFileName = opNameToFileName(opSymbol);
            var opAlias = opSymbol + "_" + namespace;
            result.push("import {" + opSymbol + " as " + opAlias + "} from '@tensorflow/tfjs-core/dist/ops/" + namespace + "/" + opFileName + "';");
        }
        result.push("export const " + namespace + " = {");
        for (var _a = 0, opSymbols_2 = opSymbols; _a < opSymbols_2.length; _a++) {
            var opSymbol = opSymbols_2[_a];
            var opAlias = opSymbol + "_" + namespace;
            result.push("\t" + opSymbol + ": " + opAlias + ",");
        }
        result.push("};");
        return result.join('\n');
    }
};
function getBackendPath(backend) {
    switch (backend) {
        case 'cpu':
            return '@tensorflow/tfjs-backend-cpu';
        case 'webgl':
            return '@tensorflow/tfjs-backend-webgl';
        case 'wasm':
            return '@tensorflow/tfjs-backend-wasm';
        default:
            throw new Error("Unsupported backend " + backend);
    }
}
function kernelNameToVariableName(kernelName) {
    return kernelName.charAt(0).toLowerCase() + kernelName.slice(1);
}
function opNameToFileName(opName) {
    // add exceptions here.
    if (opName === 'isNaN') {
        return 'is_nan';
    }
    return opName.replace(/[A-Z]/g, function (s) { return "_" + s.toLowerCase(); });
}
//# sourceMappingURL=esm_module_provider.js.map