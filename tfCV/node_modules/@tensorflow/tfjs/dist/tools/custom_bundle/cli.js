#!/usr/bin/env node
"use strict";
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Entry point for cli tool to build custom tfjs bundles
 */
var argparse = require("argparse");
var chalk = require("chalk");
var fs = require("fs");
var path = require("path");
var mkdirp = require("mkdirp");
var tfjs_core_1 = require("@tensorflow/tfjs-core");
var custom_module_1 = require("./custom_module");
var types_1 = require("./types");
var esm_module_provider_1 = require("./esm_module_provider");
var model_parser_1 = require("./model_parser");
var DEFAULT_CUSTOM_BUNDLE_ARGS = {
    entries: [],
    models: [],
    kernels: [],
    forwardModeOnly: true,
    backends: ['cpu', 'webgl'],
};
var parser = new argparse.ArgumentParser();
parser.addArgument('--config', { help: 'path to custom bundle config file.', required: true });
function bail(errorMsg) {
    console.log(chalk.red(errorMsg));
    process.exit(1);
}
function validateArgs() {
    var args = parser.parseArgs();
    var configFilePath = args.config;
    if (!fs.existsSync(configFilePath)) {
        bail("Error: config file does not exist at " + configFilePath);
    }
    var config;
    try {
        config = JSON.parse(fs.readFileSync(configFilePath, 'utf-8'));
    }
    catch (error) {
        bail("Error could not read/parse JSON config file. \n " + error.message);
    }
    if (config.outputPath == null) {
        bail('Error: config must specify "outputPath" property');
    }
    console.log("Using custom bundle configuration from " + configFilePath + ". Final config:");
    var replacer = null;
    var space = 2;
    console.log(JSON.stringify(config, replacer, space) + "\n");
    var finalConfig = Object.assign({}, DEFAULT_CUSTOM_BUNDLE_ARGS, config);
    if (finalConfig.entries.length !== 0) {
        bail('Error: config.entries not yet supported');
    }
    // if (finalConfig.models.length !== 0) {
    // TODO validate that all these paths exist.
    // bail('Error: config.models not yet supported');
    // }
    for (var _i = 0, _a = finalConfig.backends; _i < _a.length; _i++) {
        var requestedBackend = _a[_i];
        if (requestedBackend !== types_1.SupportedBackends.cpu &&
            requestedBackend !== types_1.SupportedBackends.webgl &&
            requestedBackend !== types_1.SupportedBackends.wasm) {
            bail("Error: Unsupported backend specified '" + requestedBackend + "'");
        }
    }
    return finalConfig;
}
function getKernelNamesForConfig(config) {
    // Later on this will do a union of kernels from entries, models and kernels,
    // (and kernels used by the converter itself) Currently we only support
    // directly listing kernels. remember that this also needs to handle
    // kernels used by gradients if forwardModeOnly is false.
    // Ops in core that are implemented as custom ops may appear in tf.profile
    // they will have __op as a suffix. These do not have corresponding backend
    // kernels so we need to filter them out.
    function isNotCustomOp(kernelName) {
        // opSuffix value is defined in tfjs-core/src/operation.ts
        // duplicating it here to avoid an export.
        return !kernelName.endsWith(tfjs_core_1.OP_SCOPE_SUFFIX);
    }
    return config.kernels.filter(isNotCustomOp);
}
function getOpsForConfig(config) {
    // This will return a list of ops used by the model.json(s) passed in.
    var results = new Set();
    for (var _i = 0, _a = config.models; _i < _a.length; _i++) {
        var modelJsonPath = _a[_i];
        var modelJson = void 0;
        try {
            modelJson = JSON.parse(fs.readFileSync(modelJsonPath, 'utf-8'));
        }
        catch (e) {
            console.log("Error loading JSON file " + modelJsonPath);
            console.log(e);
        }
        var ops = model_parser_1.getOps(modelJson);
        ops.forEach(function (op) { return results.add(op); });
    }
    return Array.from(results);
}
function produceCustomTFJSModule(kernels, backends, forwardModeOnly, converterOps, outputPath) {
    var moduleStrs = custom_module_1.getCustomModuleString(kernels, backends, forwardModeOnly, esm_module_provider_1.esmModuleProvider);
    mkdirp.sync(outputPath);
    console.log("Writing custom tfjs module to " + outputPath);
    var customTfjsFileName = 'custom_tfjs.js';
    var customTfjsCoreFileName = 'custom_tfjs_core.js';
    // Write a custom module for @tensorflow/tfjs and @tensorflow/tfjs-core
    fs.writeFileSync(path.join(outputPath, customTfjsCoreFileName), moduleStrs.core);
    fs.writeFileSync(path.join(outputPath, customTfjsFileName), moduleStrs.tfjs);
    // Write a custom module tfjs-core ops used by converter executors
    if (converterOps.length > 0) {
        var converterOpsModule = custom_module_1.getCustomConverterOpsModule(converterOps, esm_module_provider_1.esmModuleProvider);
        var customConverterOpsFileName = 'custom_ops_for_converter.js';
        fs.writeFileSync(path.join(outputPath, customConverterOpsFileName), converterOpsModule);
    }
}
var customConfig = validateArgs();
var kernelsToInclude = getKernelNamesForConfig(customConfig);
var converterOps = getOpsForConfig(customConfig);
produceCustomTFJSModule(kernelsToInclude, customConfig.backends, customConfig.forwardModeOnly, converterOps, customConfig.outputPath);
//# sourceMappingURL=cli.js.map