/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core"),require("seedrandom")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core","seedrandom"],e):e((t=t||self).tf=t.tf||{},t.tf,t.seedrandom)}(this,(function(t,e,a){"use strict";function n(t,a){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&e.util.assert("complex64"!==t.dtype,()=>`${a} does not support complex64 tensors in the CPU backend.`)})}function r(t,a,n,r,s,o){const i=s.strideHeight,l=s.strideWidth,d=s.dilationHeight,h=s.dilationWidth,c=s.effectiveFilterHeight,u=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,m="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=e.buffer(s.outShape,n),g=y.values,I=s.outShape[1]*s.outShape[2]*s.outShape[3],S=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let e=0;e<s.batchSize;++e){const a=e*I,n=e*r[0];for(let e=0;e<s.inChannels;++e)for(let y=0;y<s.outHeight;++y){const I=y*i-p,k=Math.max(0,I),x=Math.min(s.inHeight,c+I),M=a+y*S;for(let a=0;a<s.outWidth;++a){const i=a*l-f,c=Math.max(0,i),p=Math.min(s.inWidth,u+i);let y=m,I=0,S=0;for(let a=k;a<x;a+=d){const s=n+a*r[1];for(let a=c;a<p;a+=h){const n=t[s+a*r[2]+e];"max"===o&&n>y?y=n:"avg"===o&&(I+=n,S++)}if(isNaN(y))break}g[M+a*b+e]="avg"===o?I/S:y}}}return y}function s(t,a,n,r,s=!1,o=!1){const i=e.buffer(r.outShape,"int32"),l=r.strideHeight,d=r.strideWidth,h=r.dilationHeight,c=r.dilationWidth,u=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=r.padInfo.top,m=r.padInfo.left,y=e.buffer(a,n,t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let a=0;a<r.outHeight;++a){const n=a*l-f;let g=n;for(;g<0;)g+=h;const I=Math.min(r.inHeight,u+n);for(let l=0;l<r.outWidth;++l){const u=l*d-m;let f=u;for(;f<0;)f+=c;const S=Math.min(r.inWidth,p+u);let b=Number.NEGATIVE_INFINITY,k=-1;for(let a=g;a<I;a+=h){const i=a-n;for(let n=f;n<S;n+=c){const l=n-u,d=y.get(t,a,n,e);d>b&&(b=d,k=s?o?((t*r.inHeight+a)*r.inWidth+n)*r.inChannels+e:(a*r.inWidth+n)*r.inChannels+e:i*p+l)}}i.set(k,t,a,l,e)}}return i}const o=e.kernel_impls.nonMaxSuppressionV3Impl,i=e.kernel_impls.split,l=e.kernel_impls.tile,d=e.kernel_impls.topkImpl,h=e.kernel_impls.whereImpl;function c(t,e,a,n){if("linear"===a)return t.linear(e);if("relu"===a)return t.relu(e);if("elu"===a)return t.elu(e);if("relu6"===a)return t.relu6(e);if("prelu"===a)return t.prelu(e,n);throw new Error(`Activation ${a} has not been implemented for the CPU backend.`)}class u extends e.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new e.DataStorage(this,e.engine())}write(t,a,n){this.firstUse&&(this.firstUse=!1,e.env().get("IS_NODE")&&e.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,a,n){this.data.set(t,{values:e,dtype:n,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:a,complexTensors:n}=this.data.get(t);if("complex64"===a){const t=this.readSync(n.real.dataId),a=this.readSync(n.imag.dataId);return e.backend_util.mergeRealAndImagArrays(t,a)}return this.data.get(t).values}bufferSync(t){const a=this.readSync(t.dataId);let n=a;if("string"===t.dtype)try{n=a.map(t=>e.util.decodeString(t))}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return e.buffer(t.shape,t.dtype,n)}makeOutput(t,a,n){const r=this.write(t,a,n);return e.engine().makeTensorFromDataId(r,a,n,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}disposeIntermediateTensorInfo(t){const e=t.dataId;if(this.data.has(e)){const t=this.data.get(e);t.refCount--,t.refCount<1&&this.disposeData(e)}}async time(t){const a=e.util.now();return t(),{kernelMs:e.util.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,a){const n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:e.engine().keep(t.clone()),imag:e.engine().keep(a.clone())},n}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,a,r){if(n(t,"slice"),e.slice_util.isSliceContinous(t.shape,a,r)){const n=e.slice_util.computeFlatOffset(a,t.strides),s=e.util.sizeFromShape(r),o=this.readSync(t.dataId);return e.tensor(o.subarray(n,n+s),r,t.dtype)}const s=e.buffer(r,t.dtype),o=this.bufferSync(t);for(let t=0;t<s.size;++t){const e=s.indexToLoc(t).map((t,e)=>t+a[e]);s.values[t]=o.get(...e)}return s.toTensor()}stridedSlice(t,a,r,s){n(t,"stridedSlice");const o=e.slice_util.computeOutShape(a,r,s);if(o.some(t=>0===t))return e.tensor([],o);const i=e.buffer(o,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;t++){const e=i.indexToLoc(t),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[t]*s[t]+a[t];i.set(l.get(...n),...e)}return i.toTensor()}diag(t){const a=this.readSync(t.dataId),n=e.buffer([t.size,t.size],t.dtype),r=n.values;for(let e=0;e<a.length;e++)r[e*t.size+e]=a[e];return n.toTensor()}unstack(t,e){const a=t.shape[e],n=new Array(t.rank-1);let r=0;for(let a=0;a<t.rank;a++)a!==e&&(n[r++]=t.shape[a]);const s=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const i=new Array(a);for(let a=0;a<i.length;a++)s[e]=a,i[a]=this.slice(t,s,o).reshape(n);return i}reverse(t,a){n(t,"reverse");const r=e.buffer(t.shape,t.dtype),s=this.bufferSync(t);for(let e=0;e<r.size;e++){const n=r.indexToLoc(e),o=n.slice();a.forEach(e=>o[e]=t.shape[e]-1-o[e]),r.set(s.get(...o),...n)}return r.toTensor()}concat(t,a){if("complex64"===t[0].dtype){const n=t.map(t=>e.real(t)),r=t.map(t=>e.imag(t));return e.complex(this.concat(n,a),this.concat(r,a))}const n=t.map(t=>{const n=e.util.sizeFromShape(t.shape.slice(a));return t.as2D(-1,n)}),r=e.backend_util.computeOutShape(n.map(t=>t.shape),1),s=e.buffer(r,t[0].dtype).values;if(1===n[0].shape[0]){let t=0;n.forEach(e=>{s.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;n.forEach(e=>{const a=this.readSync(e.dataId);let n=0;for(let o=0;o<e.shape[0];++o){const i=o*r[1]+t;for(let t=0;t<e.shape[1];++t)s[i+t]=a[n++]}t+=e.shape[1]})}const o=e.backend_util.computeOutShape(t.map(t=>t.shape),a);return e.tensor(s,o,t[0].dtype)}neg(t){return n(t,"neg"),this.multiply(e.scalar(-1),t)}add(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,n)=>({real:t+a,imag:e+n})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t+e)}addN(t){n(t,"addN");const a=t.map(t=>this.readSync(t.dataId)),r=e.buffer(t[0].shape,t[0].dtype),s=r.values;for(let e=0;e<t.length;e++){const t=a[e];for(let e=0;e<s.length;e++)s[e]+=t[e]}return r.toTensor()}softmax(t,a){const n=e.util.parseAxisParam([a],t.shape),r=e.max(t,n),s=e.backend_util.expandShapeToKeepDim(r.shape,n),o=this.subtract(t,r.reshape(s)),i=this.exp(o),l=this.sum(i,n).reshape(s);return e.div(i,l)}subtract(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,n)=>({real:t-a,imag:e-n})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t-e)}pow(t,e){return n([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,a,r,s){n([t,a],"matMul");const o=r?t.shape[1]:t.shape[2],i=r?t.shape[2]:t.shape[1],l=s?a.shape[1]:a.shape[2],d=t.shape[0],h=this.readSync(t.dataId),c=this.readSync(a.dataId),[u,p,f]=r?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[m,y,g]=s?[1,a.strides[1],a.strides[0]]:[a.strides[1],1,a.strides[0]],I=i*l,S=e.buffer([d,i,l],t.dtype),b=S.values,k=this.blockSize;for(let t=0;t<d;t++)for(let e=0;e<i;e+=k)for(let a=0;a<l;a+=k)for(let n=0;n<o;n+=k){const r=Math.min(e+k,i),s=Math.min(a+k,l),d=Math.min(n+k,o);for(let o=e;o<r;o++)for(let e=a;e<s;e++){let a=0;for(let r=n;r<d;r++)a+=h[t*u+o*p+r*f]*c[r*m+e*y+t*g];b[t*I+(o*l+e)]+=a}}return S.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:a,transposeB:n,bias:r,activation:s,preluActivationWeights:o}){let i=this.batchMatMul(t,e,a,n);return r&&(i=this.add(i,r)),s&&(i=c(this,i,s,o)),i}multiply(t,a){return"complex64"===t.dtype||"complex64"===a.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),a.cast("complex64"),(t,e,a,n)=>({real:t*a-e*n,imag:t*n+e*a})):this.broadcastedBinaryOp(t,a,e.upcastType(t.dtype,a.dtype),(t,e)=>t*e)}floorDiv(t,e){n([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,a){n(t,"sum"),e.backend_util.assertAxesAreInnerMostDims("sum",a,t.rank);const[r,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.upcastType(t.dtype,"int32"),i=e.zeros(r,o),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=0;for(let t=0;t<l;++t)a+=h[e+t];d[t]=a}return i}prod(t,a){n(t,"sum");const[r,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.upcastType(t.dtype,"int32"),i=e.zeros(r,o),l=e.util.sizeFromShape(s),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=1;for(let t=0;t<l;++t)a*=h[e+t];d[t]=a}return i}unsortedSegmentSum(t,a,r){n(t,"unsortedSegmentSum");const s=[],o=t.rank-a.rank;for(let t=0;t<o;++t)a=a.expandDims(t+1);for(let n=0;n<r;++n){const r=e.scalar(n,"int32"),o=e.equal(r,a).asType("float32").mul(t).sum(0);s.push(o)}return e.stack(s)}argMin(t,a){n(t,"argMin");const r=[a];e.backend_util.assertAxesAreInnerMostDims("argMin",r,t.rank);const[s,o]=e.backend_util.computeOutAndReduceShapes(t.shape,r),i=e.zeros(s,"int32"),l=e.util.sizeFromShape(o),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],n=0;for(let t=0;t<l;++t){const r=h[e+t];r<a&&(a=r,n=t)}d[t]=n}return i}argMax(t,a){n(t,"argMax");const r=[a];e.backend_util.assertAxesAreInnerMostDims("argMax",r,t.rank);const[s,o]=e.backend_util.computeOutAndReduceShapes(t.shape,r),i=e.zeros(s,"int32"),l=e.util.sizeFromShape(o),d=this.readSync(i.dataId),h=this.readSync(t.dataId);for(let t=0;t<d.length;++t){const e=t*l;let a=h[e],n=0;for(let t=0;t<l;++t){const r=h[e+t];r>a&&(a=r,n=t)}d[t]=n}return i}cumsum(t,a,r,s){if(n(t,"cumsum"),a!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} `+`but got axis=${a}`);const o=e.upcastType(t.dtype,"int32"),i=e.zeros(t.shape,o),l=this.readSync(i.dataId),d=this.readSync(t.dataId),h=t.shape[t.rank-1],c=s?(t,e)=>t+h-e-1:(t,e)=>t+e;for(let t=0;t<d.length;t+=h)for(let e=0;e<h;e++){const a=c(t,e);if(0===e)l[a]=r?0:d[a];else{const n=c(t,e-1);l[a]=r?d[n]+l[n]:d[a]+l[n]}}return i}equal(t,e){return n([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return n([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return n([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return n([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return n([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return n([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){n(t,"logicalNot");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)a[t]=e[t]?0:1;return this.makeOutput(a,t.shape,"bool")}logicalAnd(t,e){return n([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return n([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,a,r){n([t,a,r],"select");const s=this.readSync(t.dataId),o=this.readSync(a.dataId),i=this.readSync(r.dataId),l=e.zeros(a.shape,e.upcastType(a.dtype,r.dtype)),d=this.readSync(l.dataId);let h=0;const c=0===t.rank||t.rank>1||1===a.rank?1:e.util.sizeFromShape(a.shape.slice(1));for(let t=0;t<s.length;t++)for(let e=0;e<c;e++)1===s[t]?d[h++]=o[t]:d[h++]=i[t];return l}where(t){n([t],"where");const e=this.readSync(t.dataId);return h(t.shape,e)}topk(t,e,a){n(t,"topk");const r=this.readSync(t.dataId);return d(r,t.shape,t.dtype,e,a)}min(t,a){n(t,"min"),e.backend_util.assertAxesAreInnerMostDims("min",a,t.rank);const[r,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(r,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const n=d[e+t];n<a&&(a=n)}l[t]=a}return o}minimum(t,e){return n([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return n([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t%e;return t<0&&e<0||t>=0&&e>=0?a:(a+e)%e})}maximum(t,e){return n([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,a){n(t,"all"),e.backend_util.assertAxesAreInnerMostDims("all",a,t.rank);const[r,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(r,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const n=d[e+t];a=a&&n}l[t]=a}return o}any(t,a){n(t,"any"),e.backend_util.assertAxesAreInnerMostDims("any",a,t.rank);const[r,s]=e.backend_util.computeOutAndReduceShapes(t.shape,a),o=e.zeros(r,t.dtype),i=e.util.sizeFromShape(s),l=this.readSync(o.dataId),d=this.readSync(t.dataId);for(let t=0;t<l.length;++t){const e=t*i;let a=d[e];for(let t=0;t<i;++t){const n=d[e+t];a=a||n}l[t]=a}return o}squaredDifference(t,e){return n([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const a=t-e;return a*a})}ceil(t){n(t,"ceil");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.ceil(e[t]);return this.makeOutput(a,t.shape,"float32")}floor(t){n(t,"floor");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.floor(e[t]);return this.makeOutput(a,t.shape,"float32")}sign(t){n(t,"x");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)e[t]<0?a[t]=-1:e[t]>0?a[t]=1:a[t]=0;return this.makeOutput(a,t.shape,"float32")}isNaN(t){n(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isNaN(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isInf(t){n(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Math.abs(e[t])===1/0&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}isFinite(t){n(t,"x");const e=this.readSync(t.dataId),a=new Uint8Array(e.length);for(let t=0;t<e.length;++t)Number.isFinite(e[t])&&(a[t]=1);return this.makeOutput(a,t.shape,"bool")}round(t){n(t,"round");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const n=Math.floor(e[t]);e[t]-n<.5?a[t]=Math.floor(e[t]):e[t]-n>.5?a[t]=Math.ceil(e[t]):a[t]=n%2==0?n:n+1}return this.makeOutput(a,t.shape,"float32")}exp(t){n(t,"exp");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.exp(e[t]);return this.makeOutput(a,t.shape,"float32")}expm1(t){n(t,"expm1");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.expm1(e[t]);return this.makeOutput(a,t.shape,"float32")}log(t){n(t,"log");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const n=e[t];a[t]=Math.log(n)}return this.makeOutput(a,t.shape,"float32")}log1p(t){n(t,"log1p");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const n=e[t];a[t]=Math.log1p(n)}return this.makeOutput(a,t.shape,"float32")}sqrt(t){n(t,"sqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const n=e[t];a[t]=Math.sqrt(n)}return this.makeOutput(a,t.shape,"float32")}rsqrt(t){n(t,"rsqrt");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const n=e[t];a[t]=1/Math.sqrt(n)}return this.makeOutput(a,t.shape,"float32")}reciprocal(t){n(t,"reciprocal");const e=this.readSync(t.dataId),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=1/e[t];return this.makeOutput(a,t.shape,"float32")}linear(t){return t}relu(t){n(t,"relu");const a=e.zeros(t.shape,t.dtype),r=this.readSync(a.dataId),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t)r[t]=Math.max(0,s[t]);return a}relu6(t){n(t,"relu");const a=e.zeros(t.shape,t.dtype),r=this.readSync(a.dataId),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t)r[t]=Math.min(Math.max(0,s[t]),6);return a}prelu(t,e){return n([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){n(t,"elu");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t){const n=a[t];e[t]=n>=0?n:Math.exp(n)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){n([t,e],"eluDer");const a=new Float32Array(e.size),r=this.readSync(e.dataId),s=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const e=r[t];a[t]=e>=1?s[t]:s[t]*(e+1)}return this.makeOutput(a,e.shape,"float32")}selu(t){n(t,"selu");const a=e.backend_util.SELU_SCALEALPHA,r=e.backend_util.SELU_SCALE,s=new Float32Array(t.size),o=this.readSync(t.dataId);for(let t=0;t<o.length;++t){const e=o[t];s[t]=e>=0?r*e:a*(Math.exp(e)-1)}return this.makeOutput(s,t.shape,"float32")}clip(t,e,a){n(t,"clip");const r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let t=0;t<s.length;++t){const n=s[t];r[t]=n>a?a:n<e?e:n}return this.makeOutput(r,t.shape,t.dtype)}abs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.abs(a[t]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let n=0;n<t.size;++n){const t=a[2*n],r=a[2*n+1];e[n]=Math.hypot(t,r)}return this.makeOutput(e,t.shape,"float32")}int(t){n(t,"int");const e=new Int32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=a[t];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){n(t,"sigmoid");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=1/(1+Math.exp(-a[t]));return this.makeOutput(e,t.shape,"float32")}softplus(t){n(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const n=r[t]>-e,s=r[t]<e,o=Math.exp(r[t]);let i;i=s?o:n?r[t]:Math.log(1+o),a[t]=i}return this.makeOutput(a,t.shape,"float32")}sin(t){n(t,"sin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sin(a[t]);return this.makeOutput(e,t.shape,"float32")}tan(t){n(t,"tan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.tan(a[t]);return this.makeOutput(e,t.shape,"float32")}asin(t){n(t,"asin");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asin(a[t]);return this.makeOutput(e,t.shape,"float32")}acos(t){n(t,"acos");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acos(a[t]);return this.makeOutput(e,t.shape,"float32")}atan(t){n(t,"atan");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atan(a[t]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return n([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){n(t,"sinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.sinh(a[t]);return this.makeOutput(e,t.shape,"float32")}cosh(t){n(t,"cosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.cosh(a[t]);return this.makeOutput(e,t.shape,"float32")}tanh(t){n(t,"tanh");const a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t)a[t]=e.util.tanh(r[t]);return this.makeOutput(a,t.shape,"float32")}asinh(t){n(t,"asinh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.asinh(a[t]);return this.makeOutput(e,t.shape,"float32")}acosh(t){n(t,"acosh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.acosh(a[t]);return this.makeOutput(e,t.shape,"float32")}atanh(t){n(t,"atanh");const e=new Float32Array(t.size),a=this.readSync(t.dataId);for(let t=0;t<a.length;++t)e[t]=Math.atanh(a[t]);return this.makeOutput(e,t.shape,"float32")}erf(t){n(t,"erf");const a=new Float32Array(t.size),r=this.readSync(t.dataId),s=e.backend_util.ERF_P,o=e.backend_util.ERF_A1,i=e.backend_util.ERF_A2,l=e.backend_util.ERF_A3,d=e.backend_util.ERF_A4,h=e.backend_util.ERF_A5;for(let t=0;t<r.length;++t){const e=Math.sign(r[t]),n=Math.abs(r[t]),c=1/(1+s*n);a[t]=e*(1-((((h*c+d)*c+l)*c+i)*c+o)*c*Math.exp(-n*n))}return this.makeOutput(a,t.shape,"float32")}step(t,e=0){n(t,"step");const a=new Float32Array(t.size),r=this.readSync(t.dataId);for(let t=0;t<r.length;++t){const n=r[t];isNaN(n)?a[t]=NaN:a[t]=n>0?1:e}return this.makeOutput(a,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:a,bias:n,activation:r,preluActivationWeights:s}){let o=this.conv2d(t,e,a);return n&&(o=this.add(o,n)),r&&(o=c(this,o,r,s)),o}conv2d(t,a,r){n([t,a],"conv2d");const s=r.filterHeight,o=r.filterWidth,i=r.dilationHeight,l=r.dilationWidth,d=r.padInfo.left,h=r.padInfo.top,c="channelsLast"===r.dataFormat,u=e.buffer(r.outShape,t.dtype),p=t.strides[0],f=c?t.strides[1]:t.strides[2],m=c?t.strides[2]:1,y=c?1:t.strides[1],g=u.strides[0],I=c?u.strides[1]:u.strides[2],S=c?u.strides[2]:1,b=c?1:u.strides[1],k=this.readSync(t.dataId),x=this.readSync(a.dataId),M=u.values;for(let t=0;t<r.batchSize;++t){const e=t*p,n=t*g;for(let t=0;t<r.outHeight;++t){const c=n+t*I,u=t*r.strideHeight-h;for(let t=0;t<s;t++){const n=u+t*i;if(n<0||n>=r.inHeight)continue;const s=t*a.strides[0],h=e+n*f;for(let t=0;t<r.outWidth;++t){const e=c+t*S,n=t*r.strideWidth-d;for(let t=0;t<o;t++){const o=n+t*l;if(o<0||o>=r.inWidth)continue;const i=h+o*m;let d=s+t*a.strides[1];for(let t=0;t<r.inChannels;++t){const a=k[i+t*y];for(let t=0;t<r.outChannels;++t)M[e+t*b]+=a*x[d+t];d+=r.outChannels}}}}}}return u.toTensor()}conv3d(t,a,n){const r=n.filterDepth,s=n.filterHeight,o=n.filterWidth,i=n.dilationDepth,l=n.dilationHeight,d=n.dilationWidth,h=n.padInfo.front,c=n.padInfo.left,u=n.padInfo.top,p=e.buffer(n.outShape,t.dtype),f=this.readSync(t.dataId),m=this.readSync(a.dataId),y=p.values;for(let e=0;e<n.batchSize;++e){const g=e*t.strides[0],I=e*p.strides[0];for(let e=0;e<n.outDepth;++e){const S=I+e*p.strides[1],b=e*n.strideDepth-h;for(let e=0;e<r;e++){const r=b+e*i;if(r<0||r>=n.inDepth)continue;const h=e*a.strides[0],I=g+r*t.strides[1];for(let e=0;e<n.outHeight;++e){const r=S+e*p.strides[2],i=e*n.strideHeight-u;for(let e=0;e<s;e++){const s=i+e*l;if(s<0||s>=n.inHeight)continue;const u=h+e*a.strides[1],p=I+s*t.strides[2];for(let t=0;t<n.outWidth;++t){const e=r+t*n.outChannels,s=t*n.strideWidth-c;for(let t=0;t<o;t++){const r=s+t*d;if(r<0||r>=n.inWidth)continue;const o=u+t*a.strides[2],i=p+r*n.inChannels;let l=o;for(let t=0;t<n.inChannels;++t){const a=f[i+t];for(let t=0;t<n.outChannels;++t)y[e+t]+=a*m[l+t];l+=n.outChannels}}}}}}}}return p.toTensor()}conv2dDerInput(t,a,r){n([t,a],"conv2dDerInput");const s=e.buffer(r.inShape,"float32"),o=s.values,i=this.readSync(t.dataId),l=this.readSync(a.dataId),[d,h,c]=a.strides,{batchSize:u,filterHeight:p,filterWidth:f,inChannels:m,inHeight:y,inWidth:g,outChannels:I,outHeight:S,outWidth:b,strideHeight:k,strideWidth:x,dataFormat:M}=r,F=p-1-r.padInfo.top,A=f-1-r.padInfo.left,v="channelsLast"===M,T=s.strides[0],D=v?s.strides[1]:s.strides[2],N=v?s.strides[2]:1,z=v?1:s.strides[1],w=t.strides[0],W=v?t.strides[1]:t.strides[2],H=v?t.strides[2]:1,_=v?1:t.strides[1];for(let t=0;t<u;++t)for(let e=0;e<m;++e)for(let a=0;a<y;++a){const n=a-F,r=Math.max(0,Math.ceil(n/k)),s=Math.min(S,(p+n)/k);for(let u=0;u<g;++u){const m=u-A,y=Math.max(0,Math.ceil(m/x)),g=Math.min(b,(f+m)/x);let S=0;for(let a=r;a<s;++a){const r=a*k-n;for(let n=y;n<g;++n){const s=w*t+W*a+H*n,o=d*(p-1-r)+h*(f-1-(n*x-m))+c*e;for(let t=0;t<I;++t){S+=i[s+_*t]*l[o+t]}}}o[T*t+D*a+N*u+z*e]=S}}return s.toTensor()}conv3dDerInput(t,a,n){const r=e.buffer(n.inShape,"float32"),s=r.values,[o,i,l,d]=r.strides,h=this.readSync(t.dataId),[c,u,p,f]=t.strides,m=this.readSync(a.dataId),[y,g,I,S]=a.strides,{batchSize:b,filterDepth:k,filterHeight:x,filterWidth:M,inChannels:F,inDepth:A,inHeight:v,inWidth:T,outChannels:D,outDepth:N,outHeight:z,outWidth:w,strideDepth:W,strideHeight:H,strideWidth:_}=n,O=k-1-n.padInfo.front,C=x-1-n.padInfo.top,B=M-1-n.padInfo.left;for(let t=0;t<b;++t)for(let e=0;e<F;++e)for(let a=0;a<A;++a){const n=a-O,r=Math.max(0,Math.ceil(n/W)),b=Math.min(N,(k+n)/W);for(let F=0;F<v;++F){const A=F-C,v=Math.max(0,Math.ceil(A/H)),N=Math.min(z,(x+A)/H);for(let z=0;z<T;++z){const T=z-B,O=Math.max(0,Math.ceil(T/_)),C=Math.min(w,(M+T)/_);let E=0;for(let a=r;a<b;++a){const r=a*W-n;for(let n=v;n<N;++n){const s=n*H-A;for(let o=O;o<C;++o){const i=c*t+u*a+p*n+f*o,l=y*(k-1-r)+g*(x-1-s)+I*(M-1-(o*_-T))+S*e;for(let t=0;t<D;++t){E+=h[i+t]*m[l+t]}}}}s[o*t+i*a+l*F+d*z+e]=E}}}return r.toTensor()}conv2dDerFilter(t,a,r){n([t,a],"conv2dDerFilter");const s=r.strideHeight,o=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d="channelsLast"===r.dataFormat,h=e.buffer(r.filterShape,"float32"),c=r.padInfo.left,u=r.padInfo.top,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((u-t)/s)),a=Math.min(r.outHeight,(r.inHeight+u-t)/s);for(let n=0;n<l;++n){const i=Math.max(0,Math.ceil((c-n)/o)),l=Math.min(r.outWidth,(r.inWidth+c-n)/o);for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outChannels;++y){let g=0;for(let h=0;h<r.batchSize;++h)for(let r=e;r<a;++r){const e=t+r*s-u;for(let t=i;t<l;++t){const a=n+t*o-c;g+=d?p.get(h,e,a,m)*f.get(h,r,t,y):p.get(h,m,e,a)*f.get(h,y,r,t)}}h.set(g,t,n,m,y)}}}return h.toTensor()}conv3dDerFilter(t,a,n){const r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.filterDepth,l=n.filterHeight,d=n.filterWidth,h=e.buffer(n.filterShape,"float32"),c=h.values,[u,p,f,m]=h.strides,y=this.readSync(a.dataId),[g,I,S,b]=a.strides,k=this.readSync(t.dataId),[x,M,F,A]=t.strides,v=n.padInfo.front,T=n.padInfo.left,D=n.padInfo.top;for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((v-t)/r)),a=Math.min(n.outDepth,(n.inDepth+v-t)/r),i=t*u;for(let h=0;h<l;++h){const l=Math.max(0,Math.ceil((D-h)/s)),u=Math.min(n.outHeight,(n.inHeight+D-h)/s),N=h*p+i;for(let i=0;i<d;++i){const d=Math.max(0,Math.ceil((T-i)/o)),p=Math.min(n.outWidth,(n.inWidth+T-i)/o),z=i*f+N;for(let f=0;f<n.inChannels;++f){const N=f*m+z;for(let m=0;m<n.outChannels;++m){let z=0;for(let c=0;c<n.batchSize;++c){const n=c*x,N=c*g;for(let c=e;c<a;++c){const e=(t+c*r-v)*M+n,a=c*I+N;for(let t=l;t<u;++t){const n=(h+t*s-D)*F+e,r=t*S+a;for(let t=d;t<p;++t){const e=t*b+r;z+=k[(i+t*o-T)*A+n+f]*y[e+m]}}}}c[N+m]=z}}}}}return h.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:a,bias:n,activation:r,preluActivationWeights:s}){let o=this.depthwiseConv2D(t,e,a);return n&&(o=this.add(o,n)),r&&(o=c(this,o,r,s)),o}depthwiseConv2D(t,a,r){n([t,a],"depthwiseConv2D");const s=r.filterHeight,o=r.filterWidth,i=r.dilationHeight,l=r.dilationWidth,d=r.padInfo.left,h=r.padInfo.top,c=r.outChannels/r.inChannels,u=e.buffer(r.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(a.dataId),m=u.values;for(let e=0;e<r.batchSize;++e){const n=e*t.strides[0],y=e*u.strides[0];for(let e=0;e<r.outHeight;++e){const g=y+e*u.strides[1],I=e*r.strideHeight-d;for(let e=0;e<s;++e){const s=I+e*i;if(s<0||s>=r.inHeight)continue;const d=e*a.strides[0],y=n+s*t.strides[1];for(let t=0;t<r.outWidth;++t){const e=g+t*u.strides[2],n=t*r.strideWidth-h;for(let t=0;t<o;++t){const s=n+t*l;if(s<0||s>=r.inWidth)continue;const o=d+t*a.strides[1],i=y+s*r.inChannels;let h=e,u=o;for(let t=0;t<r.inChannels;++t){const e=p[i+t];for(let t=0;t<c;++t)m[h+t]+=e*f[u+t];h+=c,u+=c}}}}}}return u.toTensor()}depthwiseConv2DDerInput(t,a,r){n([t,a],"depthwiseConv2DDerInput");const s=e.buffer(r.inShape,"float32"),o=s.values,[i,l,d]=s.strides,h=this.readSync(t.dataId),[c,u,p]=t.strides,f=this.readSync(a.dataId),[m,y,g]=a.strides,{batchSize:I,filterHeight:S,filterWidth:b,inChannels:k,inHeight:x,inWidth:M,outChannels:F,outHeight:A,outWidth:v,strideHeight:T,strideWidth:D}=r,N=S-1-r.padInfo.top,z=b-1-r.padInfo.left,w=F/k;for(let t=0;t<I;++t)for(let e=0;e<k;++e)for(let a=0;a<x;++a){const n=a-N,r=Math.max(0,Math.ceil(n/T)),s=Math.min(A,(S+n)/T);for(let I=0;I<M;++I){const k=I-z,x=Math.max(0,Math.ceil(k/D)),M=Math.min(v,(b+k)/D);let F=0;for(let a=r;a<s;++a){const r=a*T-n;for(let n=x;n<M;++n){const s=c*t+u*a+p*n,o=m*(S-1-r)+y*(b-1-(n*D-k))+g*e;for(let t=0;t<w;++t){F+=h[s+(e*w+t)]*f[o+t]}}}o[i*t+l*a+d*I+e]=F}}return s.toTensor()}depthwiseConv2DDerFilter(t,a,r){n([t,a],"depthwiseConv2DDerFilter");const s=r.strideHeight,o=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d=e.buffer(r.filterShape,"float32"),h=r.padInfo.left,c=r.padInfo.top,u=r.outChannels/r.inChannels,p=this.bufferSync(t),f=this.bufferSync(a);for(let t=0;t<i;++t){const e=Math.max(0,Math.ceil((c-t)/s)),a=Math.min(r.outHeight,(r.inHeight+c-t)/s);for(let n=0;n<l;++n){const i=Math.max(0,Math.ceil((h-n)/o)),l=Math.min(r.outWidth,(r.inWidth+h-n)/o);for(let m=0;m<r.outChannels;++m){const y=Math.trunc(m/u),g=m%u;let I=0;for(let d=0;d<r.batchSize;++d)for(let r=e;r<a;++r){const e=t+r*s-c;for(let t=i;t<l;++t){const a=n+t*o-h;I+=p.get(d,e,a,y)*f.get(d,r,t,m)}}d.set(I,t,n,y,g)}}}return d.toTensor()}tile(t,e){return n(t,"tile"),l(this.bufferSync(t),e)}gather(t,a,r){n([t,a],"gather");const s=t.shape.slice(),o=this.readSync(a.dataId);s[r]=o.length;const i=e.buffer(s,t.dtype),l=this.bufferSync(t);for(let t=0;t<i.size;++t){const e=i.indexToLoc(t),a=e.slice();a[r]=o[e[r]];const n=l.locToIndex(a);i.values[t]=l.values[n]}return i.toTensor()}batchToSpaceND(t,a,r){n([t],"batchToSpaceND");const s=a.reduce((t,e)=>t*e),o=e.backend_util.getReshaped(t.shape,a,s),i=e.backend_util.getPermuted(o.length,a.length),l=e.backend_util.getReshapedPermuted(t.shape,a,s),d=e.backend_util.getSliceBeginCoords(r,a.length),h=e.backend_util.getSliceSize(l,r,a.length);return e.transpose(t.reshape(o),i).reshape(l).slice(d,h)}maxPool(t,e){return n(t,"maxPool"),r(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,a,r,o){n([a,r],"maxPoolBackprop");const i=this.readSync(a.dataId),l=e.buffer(o.outShape,a.dtype,s(i,a.shape,a.dtype,o).values),d=o.strideHeight,h=o.strideWidth,c=o.dilationHeight,u=o.dilationWidth,p=o.effectiveFilterHeight,f=o.effectiveFilterWidth,m=f-1-o.padInfo.left,y=p-1-o.padInfo.top,g=e.buffer(a.shape,"float32"),I=this.bufferSync(t);for(let t=0;t<o.batchSize;++t)for(let e=0;e<o.inChannels;++e)for(let a=0;a<o.inHeight;++a)for(let n=0;n<o.inWidth;++n){const r=a-y,s=n-m;let i=0;for(let a=0;a<p;a+=c){const n=(r+a)/d;if(!(n<0||n>=o.outHeight||Math.floor(n)!==n))for(let r=0;r<f;r+=u){const d=(s+r)/h;if(d<0||d>=o.outWidth||Math.floor(d)!==d)continue;const c=p*f-1-l.get(t,n,d,e)===a*f+r?1:0;0!==c&&(i+=I.get(t,n,d,e)*c)}}g.set(i,t,a,n,e)}return g.toTensor()}avgPoolBackprop(t,a,r){n([t,a],"avgPoolBackprop");const s=r.strideHeight,o=r.strideWidth,i=r.filterHeight,l=r.filterWidth,d=r.dilationHeight,h=r.dilationWidth,c=r.effectiveFilterHeight,u=r.effectiveFilterWidth,p=u-1-r.padInfo.left,f=c-1-r.padInfo.top,m=e.buffer(a.shape,"float32"),y=1/(i*l),g=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let a=0;a<r.inHeight;++a)for(let n=0;n<r.inWidth;++n){const i=a-f,l=n-p;let I=0;for(let a=0;a<c;a+=d){const n=(i+a)/s;if(!(n<0||n>=r.outHeight||Math.floor(n)!==n))for(let a=0;a<u;a+=h){const s=(l+a)/o;s<0||s>=r.outWidth||Math.floor(s)!==s||(I+=g.get(t,n,s,e))}}m.set(I*y,t,a,n,e)}return m.toTensor()}pool3d(t,a,r){n(t,"pool3d");const s=a.strideDepth,o=a.strideHeight,i=a.strideWidth,l=a.dilationDepth,d=a.dilationHeight,h=a.dilationWidth,c=a.effectiveFilterDepth,u=a.effectiveFilterHeight,p=a.effectiveFilterWidth,f=a.padInfo.front,m=a.padInfo.top,y=a.padInfo.left,g="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=this.readSync(t.dataId),S=e.buffer(a.outShape,t.dtype),b=S.values,k=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],x=a.outShape[2]*a.outShape[3]*a.outShape[4],M=a.outShape[3]*a.outShape[4],F=a.outShape[4];for(let e=0;e<a.batchSize;++e){const n=e*k,S=e*t.strides[0];for(let e=0;e<a.inChannels;++e)for(let k=0;k<a.outDepth;++k){const A=k*s-f;let v=A;for(;v<0;)v+=l;const T=Math.min(a.inDepth,c+A),D=n+k*x;for(let n=0;n<a.outHeight;++n){const s=n*o-m;let c=s;for(;c<0;)c+=d;const f=Math.min(a.inHeight,u+s),k=D+n*M;for(let n=0;n<a.outWidth;++n){const s=n*i-y;let o=s;for(;o<0;)o+=h;const u=Math.min(a.inWidth,p+s),m=k+n*F;let x=g,M=0,A=0;for(let a=v;a<T;a+=l){const n=S+a*t.strides[1];for(let a=c;a<f;a+=d){const s=n+a*t.strides[2];for(let a=o;a<u;a+=h){const n=I[s+a*t.strides[3]+e];if("max"===r&&n>x?x=n:"avg"===r&&(M+=n,A++),isNaN(x))break}if(isNaN(x))break}if(isNaN(x))break}b[m+e]="avg"===r?M/A:x}}}}return S.toTensor()}avgPool3d(t,e){return n(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,a,r){n([t,a],"avgPool3dBackprop");const s=r.strideDepth,o=r.strideHeight,i=r.strideWidth,l=r.filterDepth,d=r.filterHeight,h=r.filterWidth,c=r.dilationDepth,u=r.dilationHeight,p=r.dilationWidth,f=r.effectiveFilterDepth,m=r.effectiveFilterHeight,y=r.effectiveFilterWidth,g=f-1-r.padInfo.front,I=y-1-r.padInfo.left,S=m-1-r.padInfo.top,b=e.buffer(a.shape,"float32"),k=1/(l*d*h),x=this.bufferSync(t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let a=0;a<r.inDepth;++a)for(let n=0;n<r.inHeight;++n)for(let l=0;l<r.inWidth;++l){const d=a-g,h=n-S,M=l-I;let F=0;for(let a=0;a<f;a+=c){const n=(d+a)/s;if(!(n<0||n>=r.outDepth||Math.floor(n)!==n))for(let a=0;a<m;a+=u){const s=(h+a)/o;if(!(s<0||s>=r.outHeight||Math.floor(s)!==s))for(let a=0;a<y;a+=p){const o=(M+a)/i;o<0||o>=r.outWidth||Math.floor(o)!==o||(F+=x.get(t,n,s,o,e))}}}b.set(F*k,t,a,n,l,e)}return b.toTensor()}maxPool3d(t,e){return n(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,a){const n=e.buffer(a.outShape,"int32"),r=a.strideDepth,s=a.strideHeight,o=a.strideWidth,i=a.dilationDepth,l=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,c=a.effectiveFilterHeight,u=a.effectiveFilterWidth,p=a.padInfo.front,f=a.padInfo.top,m=a.padInfo.left,y=this.bufferSync(t);for(let t=0;t<a.batchSize;++t)for(let e=0;e<a.inChannels;++e)for(let g=0;g<a.outDepth;++g){const I=g*r-p;let S=I;for(;S<0;)S+=i;const b=Math.min(a.inDepth,h+I);for(let r=0;r<a.outHeight;++r){const h=r*s-f;let p=h;for(;p<0;)p+=l;const k=Math.min(a.inHeight,c+h);for(let s=0;s<a.outWidth;++s){const f=s*o-m;let x=f;for(;x<0;)x+=d;const M=Math.min(a.inWidth,u+f);let F=Number.NEGATIVE_INFINITY,A=-1;for(let a=S;a<b;a+=i){const n=a-I;for(let r=p;r<k;r+=l){const s=r-h;for(let o=x;o<M;o+=d){const i=o-f,l=y.get(t,a,r,o,e);l>=F&&(F=l,A=n*c*u+s*c+i)}}}n.set(A,t,g,r,s,e)}}}return n.toTensor()}maxPool3dBackprop(t,a,r,s){n([a,r],"maxPool3dBackprop");const o=this.maxPool3dPositions(a,s),i=s.strideDepth,l=s.strideHeight,d=s.strideWidth,h=s.dilationDepth,c=s.dilationHeight,u=s.dilationWidth,p=s.effectiveFilterDepth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=p-1-s.padInfo.front,g=m-1-s.padInfo.left,I=f-1-s.padInfo.top,S=e.buffer(a.shape,"float32"),b=this.bufferSync(o),k=this.bufferSync(t);for(let t=0;t<s.batchSize;++t)for(let e=0;e<s.inChannels;++e)for(let a=0;a<s.inDepth;++a)for(let n=0;n<s.inHeight;++n)for(let r=0;r<s.inWidth;++r){const o=a-y,x=n-I,M=r-g;let F=0;for(let a=0;a<p;a+=h){const n=(o+a)/i;if(!(n<0||n>=s.outDepth||Math.floor(n)!==n))for(let r=0;r<f;r+=c){const o=(x+r)/l;if(!(o<0||o>=s.outHeight||Math.floor(o)!==o))for(let i=0;i<m;i+=u){const l=(M+i)/d;if(l<0||l>=s.outWidth||Math.floor(l)!==l)continue;const h=p*f*m-1-b.get(t,n,o,l,e)===a*f*m+r*m+i?1:0;0!==h&&(F+=k.get(t,n,o,l,e)*h)}}}S.set(F,t,a,n,r,e)}return S.toTensor()}cast(t,a){return e.backend_util.castTensor(t,a,this)}avgPool(t,e){return n(t,"avgPool"),n(t,"maxPool"),r(this.readSync(t.dataId),t.shape,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,a,r,s){n(t,"resizeBilinear");const[o,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(e.util.sizeFromShape([o,a,r,d])),u=[s&&a>1?i-1:i,s&&r>1?l-1:l],p=[s&&a>1?a-1:a,s&&r>1?r-1:r];let f=0;const m=u[0]/p[0],y=u[1]/p[1];for(let e=0;e<o;e++)for(let n=0;n<a;n++){const a=m*n,s=Math.floor(a),o=a-s,u=Math.min(i-1,Math.ceil(a)),p=e*t.strides[0]+s*t.strides[1],g=e*t.strides[0]+u*t.strides[1];for(let e=0;e<r;e++){const a=y*e,n=Math.floor(a),r=a-n,s=Math.min(l-1,Math.ceil(a)),i=p+n*t.strides[2],u=g+n*t.strides[2],m=p+s*t.strides[2],I=g+s*t.strides[2];for(let t=0;t<d;t++){const e=h[i+t],a=h[u+t],n=e+(h[m+t]-e)*r,s=n+(a+(h[I+t]-a)*r-n)*o;c[f++]=s}}}return e.tensor(c,[o,a,r,d])}resizeBilinearBackprop(t,a,r){n([t,a],"resizeBilinearBackprop");const[s,o,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(s*o*i*l),u=[r&&d>1?o-1:o,r&&h>1?i-1:i],p=[r&&d>1?d-1:d,r&&h>1?h-1:h],f=u[0]/p[0],m=u[1]/p[1],y=this.readSync(t.dataId);let g=0;for(let t=0;t<s;t++){const e=t*a.strides[0];for(let t=0;t<d;t++){const n=t*f,r=Math.floor(n),s=Math.min(Math.ceil(n),o-1),d=e+r*a.strides[1],u=e+s*a.strides[1],p=n-r,I=1-p;for(let t=0;t<h;t++){const e=t*m,n=Math.floor(e),r=Math.min(Math.ceil(e),i-1),s=e-n,o=1-s,h=d+n*a.strides[2],f=d+r*a.strides[2],S=u+n*a.strides[2],b=u+r*a.strides[2],k=I*o,x=I*s,M=p*o,F=p*s;for(let t=0;t<l;t++){const e=y[g++];c[h+t]+=e*k,c[f+t]+=e*x,c[S+t]+=e*M,c[b+t]+=e*F}}}}return e.tensor4d(c,[s,i,o,l],a.dtype)}resizeNearestNeighbor(t,a,r,s){n(t,"resizeNearestNeighbor");const[o,i,l,d]=t.shape,h=this.readSync(t.dataId),c=new Float32Array(o*a*r*d),u=[s&&a>1?i-1:i,s&&r>1?l-1:l],p=[s&&a>1?a-1:a,s&&r>1?r-1:r],f=u[0]/p[0],m=u[1]/p[1];let y=0;for(let e=0;e<o;e++){const n=e*t.strides[0];for(let e=0;e<a;e++){const a=f*e,o=n+Math.min(i-1,s?Math.round(a):Math.floor(a))*t.strides[1];for(let e=0;e<r;e++){const a=m*e,n=o+Math.min(l-1,s?Math.round(a):Math.floor(a))*t.strides[2];for(let t=0;t<d;t++){const e=h[n+t];c[y++]=e}}}}return e.tensor(c,[o,a,r,d],t.dtype)}resizeNearestNeighborBackprop(t,a,r){n([t,a],"resizeNearestNeighborBackprop");const[s,o,i,l]=a.shape,[,d,h]=t.shape,c=new Float32Array(s*o*i*l),u=this.readSync(t.dataId),p=[r&&d>1?o-1:o,r&&h>1?i-1:i],f=[r&&d>1?d-1:d,r&&h>1?h-1:h],m=p[0]/f[0],y=p[1]/f[1],g=1/m,I=1/y,S=2*Math.ceil(g)+2,b=2*Math.ceil(I)+2;for(let e=0;e<s;e++){const n=e*a.strides[0];for(let e=0;e<o;e++){const s=n+e*a.strides[1],p=Math.floor(e*g),f=Math.floor(p-S/2);for(let p=0;p<i;p++){const g=s+p*a.strides[2],k=Math.floor(p*I),x=Math.floor(k-b/2);for(let a=0;a<l;a++){let s=0;for(let l=0;l<S;l++){const c=l+f;if(c<0||c>=d)continue;const g=n+c*t.strides[1],I=c*m;if(e===Math.min(o-1,r?Math.round(I):Math.floor(I)))for(let e=0;e<b;e++){const n=e+x;if(n<0||n>=h)continue;const o=g+n*t.strides[2],l=n*y;p===Math.min(i-1,r?Math.round(l):Math.floor(l))&&(s+=u[o+a])}}c[g+a]=s}}}}return e.tensor4d(c,a.shape,a.dtype)}batchNorm(t,a,r,s,o,i){n([t,a,r,o,s],"batchNorm");const l=this.readSync(t.dataId),d=this.readSync(a.dataId),h=this.readSync(r.dataId),c=o?this.readSync(o.dataId):new Float32Array([1]),u=s?this.readSync(s.dataId):new Float32Array([0]),p=new Float32Array(l.length),f=u.length,m=c.length,y=h.length,g=d.length;let I=0,S=0,b=0,k=0;for(let t=0;t<l.length;++t)p[t]=u[I++]+(l[t]-d[S++])*c[b++]/Math.sqrt(h[k++]+i),I>=f&&(I=0),S>=g&&(S=0),b>=m&&(b=0),k>=y&&(k=0);return e.tensor4d(p,t.shape)}localResponseNormalization4D(t,a,r,s,o){n(t,"localResponseNormalization4D");const i=t.shape[3],l=i-1,d=this.readSync(t.dataId),h=t.size,c=new Float32Array(h);function u(t){const e=t%i;let n=t-e+Math.max(0,e-a);const r=t-e+Math.min(e+a,l);let s=0;for(;n<=r;n++){const t=d[n];s+=t*t}return s}for(let t=0;t<h;t++){const e=u(t),a=d[t]*Math.pow(r+s*e,-o);c[t]=a}return e.tensor4d(c,t.shape)}LRNGrad(t,a,r,s,o,i,l){n(t,"LRNGrad");const d=t.shape[3],h=this.readSync(t.dataId),c=this.readSync(a.dataId),u=this.readSync(r.dataId),p=new Float32Array(t.size),f=t.size;for(let t=0;t<f;t++){const e=t%d,a=t-e+Math.max(0,e-s),n=t-e+Math.min(d,e+s+1);let r=0;for(let t=a;t<n;t++)r+=Math.pow(c[t],2);r=i*r+o;for(let e=a;e<n;e++){let a=-2*i*l*c[e]*u[t]/r;t===e&&(a+=Math.pow(r,-l)),a*=h[t],p[e]+=a}}return e.tensor4d(p,t.shape)}multinomial(t,r,s,o){n(t,"multinomial");const i=r?t:e.softmax(t),l=i.shape[0],d=i.shape[1],h=e.zeros([l,s],"int32"),c=this.readSync(h.dataId),u=this.readSync(i.dataId);for(let t=0;t<l;++t){const e=t*d,n=new Float32Array(d-1);n[0]=u[e];for(let t=1;t<n.length;++t)n[t]=n[t-1]+u[e+t];const r=a.alea(o.toString()),i=t*s;for(let t=0;t<s;++t){const e=r();c[i+t]=n.length;for(let a=0;a<n.length;a++)if(e<n[a]){c[i+t]=a;break}}}return h}oneHot(t,a,r,s){n(t,"oneHot");const o=new Float32Array(t.size*a);o.fill(s);const i=this.readSync(t.dataId);for(let e=0;e<t.size;++e)i[e]>=0&&i[e]<a&&(o[e*a+i[e]]=r);return e.tensor2d(o,[t.size,a],"int32")}nonMaxSuppression(t,e,a,r,s){n(t,"nonMaxSuppression");const i=this.readSync(t.dataId),l=this.readSync(e.dataId);return o(i,l,a,r,s)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,a){const n=t.shape[0],r=t.shape[1],s=e.buffer(t.shape,"float32"),o=e.buffer(t.shape,"float32"),i=e.real(t).as2D(n,r),l=e.imag(t).as2D(n,r);for(let t=0;t<n;t++){const n=i.slice([t,0],[1,r]),d=l.slice([t,0],[1,r]),h=e.complex(n,d),c=this.readSync(this.fftImpl(h,a).dataId);for(let a=0;a<r;a++){const n=e.backend_util.getComplexWithIndex(c,a);s.values[t*r+a]=n.real,o.values[t*r+a]=n.imag}}return e.complex(s.toTensor(),o.toTensor()).as2D(n,r)}fftImpl(t,a){const n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){let s=this.fftRadix2(n,r,a).as2D(t.shape[0],t.shape[1]);return a&&(s=e.complex(e.real(s).div(e.scalar(r)),e.imag(s).div(e.scalar(r)))),s}{const n=this.readSync(t.dataId),s=this.fourierTransformByMatmul(n,r,a),o=e.backend_util.splitRealAndImagArrays(s);return e.complex(o.real,o.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,a,n){if(1===a)return t;const r=this.readSync(t.dataId),s=a/2,o=e.backend_util.complexWithEvenIndex(r);let i=e.complex(o.real,o.imag).as1D();const l=e.backend_util.complexWithOddIndex(r);let d=e.complex(l.real,l.imag).as1D();i=this.fftRadix2(i,s,n),d=this.fftRadix2(d,s,n);const h=e.backend_util.exponents(a,n),c=e.complex(h.real,h.imag).mul(d),u=i.add(c),p=i.sub(c),f=e.real(u).concat(e.real(p)),m=e.imag(u).concat(e.imag(p));return e.complex(f,m).as1D()}fourierTransformByMatmul(t,a,n){const r=new Float32Array(2*a);for(let s=0;s<a;s++){let o=0,i=0;for(let r=0;r<a;r++){const l=e.backend_util.exponent(s*r,a,n),d=e.backend_util.getComplexWithIndex(t,r);o+=d.real*l.real-d.imag*l.imag,i+=d.real*l.imag+d.imag*l.real}n&&(o/=a,i/=a),e.backend_util.assignToTypedArray(r,o,i,s)}return r}depthToSpace(t,a,n){e.util.assert("NHWC"===n,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${n}`),e.util.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`);const r=t.shape[0],s=t.shape[1],o=t.shape[2],i=t.shape[3],l=s*a,d=o*a,h=i/(a*a),c=this.readSync(t.dataId),u=new Float32Array(r*l*d*h);let p=0;for(let t=0;t<r;++t)for(let e=0;e<l;++e){const n=Math.floor(e/a),r=e%a;for(let e=0;e<d;++e){const l=Math.floor(e/a),d=(r*a+e%a)*h;for(let e=0;e<h;++e){const a=e+d+i*(l+o*(n+s*t));u[p++]=c[a]}}}return e.tensor4d(u,[r,l,d,h])}broadcastedBinaryOp(t,a,n,r){const s=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),o=e.buffer(s,n),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,s),h=e.backend_util.getBroadcastDims(a.shape,s),c=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;++t)c[t]=r(i[t%i.length],l[t%l.length]);else{const e=this.bufferSync(t),n=this.bufferSync(a);for(let s=0;s<c.length;++s){const u=o.indexToLoc(s),p=u.slice(-t.rank);d.forEach(t=>p[t]=0);const f=e.locToIndex(p),m=u.slice(-a.rank);h.forEach(t=>m[t]=0);const y=n.locToIndex(m);c[s]=r(i[f],l[y])}}return o.toTensor()}broadcastedBinaryComplexOp(t,a,n){const r=e.backend_util.assertAndGetBroadcastShape(t.shape,a.shape),s=e.buffer(r,"float32"),o=e.buffer(r,"float32"),i=this.readSync(t.dataId),l=this.readSync(a.dataId),d=e.backend_util.getBroadcastDims(t.shape,r),h=e.backend_util.getBroadcastDims(a.shape,r),c=s.values,u=o.values;if(d.length+h.length===0)for(let t=0;t<c.length;t++){const e=t%i.length,a=t%l.length,r=n(i[2*e],i[2*e+1],l[2*a],l[2*a+1]);c[t]=r.real,u[t]=r.imag}else{const e=this.bufferSync(this.data.get(t.dataId).complexTensors.real),r=this.bufferSync(this.data.get(a.dataId).complexTensors.real);for(let o=0;o<c.length;o++){const p=s.indexToLoc(o),f=p.slice(-t.rank);d.forEach(t=>f[t]=0);const m=e.locToIndex(f),y=p.slice(-a.rank);h.forEach(t=>y[t]=0);const g=r.locToIndex(y),I=n(i[2*m],i[2*m+1],l[2*g],l[2*g+1]);c[o]=I.real,u[o]=I.imag}}return this.complex(s.toTensor(),o.toTensor())}split(t,e,a){return i(t,e,a)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,a,n,r,s,o){const[i,l,d,h]=t.shape,c=a.shape[0],[u,p]=r,f=e.buffer([c,u,p,h],"float32"),m=this.readSync(a.dataId),y=this.readSync(n.dataId),g=this.readSync(t.dataId),I=t.strides,S=f.strides;for(let t=0;t<c;t++){const e=4*t,a=m[e],n=m[e+1],r=m[e+2],c=m[e+3],b=y[t];if(b>=i)continue;const k=u>1?(r-a)*(l-1)/(u-1):0,x=p>1?(c-n)*(d-1)/(p-1):0;for(let e=0;e<u;e++){const i=u>1?a*(l-1)+e*k:.5*(a+r)*(l-1);if(i<0||i>l-1)for(let a=0;a<p;a++)for(let n=0;n<h;n++){const r=n+a*S[2]+e*S[1]+t*S[0];f.values[r]=o}else if("bilinear"===s){const a=Math.floor(i),r=Math.ceil(i),s=i-a;for(let i=0;i<p;i++){const l=p>1?n*(d-1)+i*x:.5*(n+c)*(d-1);if(l<0||l>d-1){for(let a=0;a<h;a++){const n=a+i*S[2]+e*S[1]+t*S[0];f.values[n]=o}continue}const u=Math.floor(l),m=Math.ceil(l),y=l-u;for(let n=0;n<h;n++){let o=n+u*I[2]+a*I[1]+b*I[0];const l=g[o];o=n+m*I[2]+a*I[1]+b*I[0];const d=g[o];o=n+u*I[2]+r*I[1]+b*I[0];const h=g[o];o=n+m*I[2]+r*I[1]+b*I[0];const c=l+(d-l)*y,p=h+(g[o]-h)*y;o=n+i*S[2]+e*S[1]+t*S[0],f.values[o]=c+(p-c)*s}}}else for(let a=0;a<p;++a){const r=p>1?n*(d-1)+a*x:.5*(n+c)*(d-1);if(r<0||r>d-1){for(let n=0;n<h;n++){const r=n+a*S[2]+e*S[1]+t*S[0];f.values[r]=o}continue}const s=Math.round(r),l=Math.round(i);for(let n=0;n<h;n++){const r=n+s*I[2]+l*I[1]+b*I[0],o=n+a*S[2]+e*S[1]+t*S[0];f.values[o]=g[r]}}}}return f.toTensor()}sparseToDense(t,a,n,r){const{sliceRank:s,numUpdates:o,sliceSize:i,strides:l,outputSize:d}=e.backend_util.calculateShapes(a,t,n);return this.scatter(t,a,n,d,i,o,s,l,r,!1)}gatherND(t,a){const n=a.shape,r=n[n.length-1],[s,o,i,l]=e.backend_util.prepareAndValidate(t,a);if(0===o)return e.tensor([],s,t.dtype);const d=new e.TensorBuffer([o,i],t.dtype),h=this.readSync(a.dataId),c=this.readSync(t.dataId);for(let e=0;e<o;e++){const a=[];let n=0;for(let t=0;t<r;t++){const s=h[e*r+t];n+=s*l[t],a.push(s)}if(n<0||n>=t.size/i)throw new Error(`Invalid indices: ${a} does not index into ${t.shape}`);for(let t=0;t<i;t++)d.values[e*i+t]=c[n*i+t]}return d.toTensor().reshape(s)}scatterND(t,a,n){const{sliceRank:r,numUpdates:s,sliceSize:o,strides:i,outputSize:l}=e.backend_util.calculateShapes(a,t,n),d=e.scalar(0);return this.scatter(t,a,n,l,o,s,r,i,d,!0)}fill(t,a,n){n=n||e.util.inferDtype(a);const r=e.util.getArrayFromDType(n,e.util.sizeFromShape(t));return r.fill(a),e.engine().makeTensor(r,t,n,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const a=e.util.getArrayFromDType(t.dtype,e.util.sizeFromShape(t.shape));return this.makeOutput(a,t.shape,t.dtype)}linspace(t,a,n){return e.backend_util.linspaceImpl(t,a,n)}scatter(t,a,n,r,s,o,i,l,d,h){const c=[r/s,s],u=this.readSync(t.dataId),p=this.readSync(a.dataId);if(0===r)return e.tensor([],n,a.dtype);const f=new e.TensorBuffer(c,a.dtype);f.values.fill(this.readSync(d.dataId)[0]);for(let t=0;t<o;t++){const e=[];let o=0;for(let a=0;a<i;a++){const n=u[t*i+a];e.push(n),o+=n*l[a]}if(o<0||o>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let e=0;e<s;e++)h?f.values[o*s+e]+=p[t*s+e]:f.values[o*s+e]=0===a.rank?p[0]:p[t*s+e]}return f.toTensor().reshape(n)}}function p(t,a,n,r){const s=e.util.getTypedArrayFromDType(r,e.util.sizeFromShape(n));for(let e=0;e<s.length;++e){const n=e*a;let r=t[n];for(let e=0;e<a;++e){const a=t[n+e];a>r&&(r=a)}s[e]=r}return s}function f(t,a,n,r,s){const o=a.length,i=e.util.sizeFromShape(a),l=e.util.computeStrides(a),d=e.util.computeStrides(s),h=e.util.getTypedArrayFromDType(n,e.util.sizeFromShape(s));for(let a=0;a<i;++a){const n=e.util.indexToLoc(a,o,l),s=new Array(n.length);for(let t=0;t<s.length;t++)s[t]=n[r[t]];h[e.util.locToIndex(s,o,d)]=t[a]}return h}var m=Object.freeze({__proto__:null,maxImpl:p,transposeImpl:f});e.registerBackend("cpu",()=>new u,1);const y={kernelName:e.Cos,backendName:"cpu",kernelFunc:({inputs:t,backend:a})=>{const{x:r}=t,s=a;n(r,"cos");const o=s.data.get(r.dataId).values,i=e.util.sizeFromShape(r.shape),l=new Float32Array(i);for(let t=0;t<i;++t)l[t]=Math.cos(o[t]);return{dataId:s.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},g={kernelName:e.Dilation2D,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:n})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:l}=n,d=a,h=d.data.get(r.dataId).values,c=r.shape.length,u=d.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:y,inChannels:g,outHeight:I,outWidth:S,padInfo:b,strideHeight:k,strideWidth:x,filterHeight:M,filterWidth:F,dilationHeight:A,dilationWidth:v,outShape:T}=e.backend_util.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",l),D=e.util.sizeFromShape(T),N=T.length,z=e.util.getArrayFromDType(r.dtype,D);for(let t=0;t<f;++t)for(let a=0;a<I;++a){const n=a*k-b.top;for(let o=0;o<S;++o){const i=o*x-b.left;for(let l=0;l<g;++l){let d=Number.MIN_SAFE_INTEGER;for(let a=0;a<M;++a){const o=n+a*A;if(o>=0&&o<m)for(let n=0;n<F;++n){const f=i+n*v;if(f>=0&&f<y){const i=e.util.locToIndex([t,o,f,l],c,e.util.computeStrides(r.shape)),m=e.util.locToIndex([a,n,l],p,e.util.computeStrides(s.shape)),y=h[i]+u[m];y>d&&(d=y)}}}z[e.util.locToIndex([t,a,o,l],N,e.util.computeStrides(T))]=d}}}return{dataId:d.write(e.util.toTypedArray(z,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},I={kernelName:e.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:l,dilations:d}=n,h=a,c=e.util.toNestedArray(r.shape,h.data.get(r.dataId).values),u=e.util.toNestedArray(s.shape,h.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:I,padInfo:S,strideHeight:b,strideWidth:k,filterHeight:x,filterWidth:M,dilationHeight:F,dilationWidth:A,outShape:v}=e.backend_util.computeDilation2DInfo(r.shape,s.shape,i,l,"NHWC",d);e.util.assert(o.rank===v.length,()=>`Error in ${e.Dilation2DBackpropFilter}, dy `+`must have the same rank as output ${v.length}, but got `+`${o.rank}`);const T=e.util.toNestedArray(v,h.data.get(o.dataId).values),D=e.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let t=0;t<p;++t)for(let e=0;e<g;++e){const a=e*b-S.top;for(let n=0;n<I;++n){const r=n*k-S.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,i=0,l=0;for(let e=0;e<x;++e){const n=a+e*F;if(n>=0&&n<f)for(let a=0;a<M;++a){const d=r+a*A;if(d>=0&&d<m){const r=c[t][n][d][s]+u[e][a][s];r>o&&(o=r,i=e,l=a)}}}D[i][l][s]+=T[t][e][n][s]}}}return{dataId:h.write(e.util.toTypedArray(D,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},S={kernelName:e.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:t,backend:a,attrs:n})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:l,dilations:d}=n,h=a,c=e.util.toNestedArray(r.shape,h.data.get(r.dataId).values),u=e.util.toNestedArray(s.shape,h.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:I,padInfo:S,strideHeight:b,strideWidth:k,filterHeight:x,filterWidth:M,dilationHeight:F,dilationWidth:A,outShape:v}=e.backend_util.computeDilation2DInfo(r.shape,s.shape,i,l,"NHWC",d);e.util.assert(o.rank===v.length,()=>`Error in ${e.Dilation2DBackpropInput}, dy `+`must have the same rank as output ${v.length}, but got `+`${o.rank}`);const T=e.util.toNestedArray(v,h.data.get(o.dataId).values),D=e.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let t=0;t<p;++t)for(let e=0;e<g;++e){const a=e*b-S.top;for(let n=0;n<I;++n){const r=n*k-S.left;for(let s=0;s<y;++s){let o=Number.MIN_SAFE_INTEGER,i=a<0?0:a,l=r<0?0:r;for(let e=0;e<x;++e){const n=a+e*F;if(n>=0&&n<f)for(let a=0;a<M;++a){const d=r+a*A;if(d>=0&&d<m){const r=c[t][n][d][s]+u[e][a][s];r>o&&(o=r,i=n,l=d)}}}D[t][i][l][s]+=T[t][e][n][s]}}}return{dataId:h.write(e.util.toTypedArray(D,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function b(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:a,backend:r})=>{const{a:s,b:o}=a,i=r;n([s,o],t);const l=i.data.get(s.dataId).values,d=i.data.get(o.dataId).values,[h,c]=e(s.shape,o.shape,l,d,s.dtype);return{dataId:i.write(h,c,s.dtype),shape:c,dtype:s.dtype}}}}function k(t){return(a,n,r,s,o)=>{const i=e.backend_util.assertAndGetBroadcastShape(a,n),l=i.length,d=e.util.computeStrides(i),h=e.util.sizeFromShape(i),c=e.util.getTypedArrayFromDType(o,h),u=a.length,p=n.length,f=e.util.computeStrides(a),m=e.util.computeStrides(n),y=e.backend_util.getBroadcastDims(a,i),g=e.backend_util.getBroadcastDims(n,i);if(y.length+g.length===0)for(let e=0;e<c.length;++e)c[e]=t(r[e%r.length],s[e%s.length]);else for(let a=0;a<c.length;++a){const n=e.util.indexToLoc(a,l,d),o=n.slice(-u);y.forEach(t=>o[t]=0);const i=e.util.locToIndex(o,u,f),h=n.slice(-p);g.forEach(t=>h[t]=0);const I=e.util.locToIndex(h,p,m);c[a]=t(r[i],s[I])}return[c,i]}}const x=k((t,e)=>t/e),M=b(e.Div,x),F={kernelName:e.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:n})=>{const{image:r}=t,s=n,o=e.util.getTypedArrayFromDType(r.dtype,e.util.sizeFromShape(r.shape)),[i,l,d,h]=r.shape,c=s.data.get(r.dataId).values;for(let t=0;t<i;t++){const e=t*d*l*h;for(let t=0;t<l;t++){const a=t*(d*h);for(let n=0;n<d;n++){const r=n*h;for(let s=0;s<h;s++){const l=[i,t,n,s][2],u=Math.round(d-l),p=e+a+r+s;let f=c[p];if(u>=0&&u<d){f=c[e+a+u*h+s]}o[p]=f}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const A={kernelName:e.Identity,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:a}=t,{x:n}=e;return a.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}},v={kernelName:e.Max,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:r})=>{const{x:s}=t,{reductionIndices:o,keepDims:i}=a,l=r;let d=s.shape;const h=d.length,c=e.util.parseAxisParam(o,d);let u=c;const m=e.backend_util.getAxesPermutation(u,h);let y=l.data.get(s.dataId).values;if(null!=m){const t=new Array(h);for(let e=0;e<t.length;e++)t[e]=d[m[e]];y=f(y,d,s.dtype,m,t),u=e.backend_util.getInnerMostAxes(u.length,h),d=t}n(s,"max"),e.backend_util.assertAxesAreInnerMostDims("max",u,h);const[g,I]=e.backend_util.computeOutAndReduceShapes(d,u),S=p(y,e.util.sizeFromShape(I),g,s.dtype),b=l.write(S,g,s.dtype);let k=g;if(i){k=e.backend_util.expandShapeToKeepDim(g,c)}return{dataId:b,shape:k,dtype:s.dtype}}};const T={kernelName:e.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:o})=>{const{x:i}=t,{filterSize:l,strides:d,pad:h,includeBatchInIndex:c}=a,u=o;n(i,"MaxPoolWithArgmax");const p=u.data.get(i.dataId).values,f=e.backend_util.computePool2DInfo(i.shape,l,d,[1,1],h),[m,y]=function(t,a,n,o,i){const l=r(t,0,n,e.util.computeStrides(a),i,"max"),d=s(t,a,n,i,!0,o);return[l.values,d.values]}(p,i.shape,i.dtype,c,f),g=u.write(m,f.outShape,i.dtype),I=u.write(y,f.outShape,i.dtype);return[{dataId:g,shape:f.outShape,dtype:i.dtype},{dataId:I,shape:f.outShape,dtype:"int32"}]}},D=e.kernel_impls.nonMaxSuppressionV4Impl,N={kernelName:e.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:a})=>{const{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:d}=a,h=e;n(r,"NonMaxSuppressionPadded");const c=h.data.get(r.dataId).values,u=h.data.get(s.dataId).values,{selectedIndices:p,validOutputs:f}=D(c,u,o,i,l,d);return[p,f]}},z=e.kernel_impls.nonMaxSuppressionV5Impl,w={kernelName:e.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:a})=>{const{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:d}=a,h=e;n(r,"NonMaxSuppressionWithScore");const c=h.data.get(r.dataId).values,u=h.data.get(s.dataId).values,p=o,f=i,m=l,y=d,{selectedIndices:g,selectedScores:I}=z(c,u,p,f,m,y);return[g,I]}};const W={kernelName:e.PadV2,backendName:"cpu",kernelFunc:function(t){const{inputs:a,backend:r,attrs:s}=t,{x:o}=a,{paddings:i,constantValue:l}=s;n(o,"pad");const d=i.map((t,e)=>t[0]+o.shape[e]+t[1]),h=i.map(t=>t[0]),c=r.data.get(o.dataId).values,u=e.util.sizeFromShape(o.shape),p=o.shape.length,f=e.util.computeStrides(o.shape),m=e.util.sizeFromShape(d),y=d.length,g=e.util.computeStrides(d),I=e.util.getTypedArrayFromDType(o.dtype,m);0!==l&&I.fill(l);for(let t=0;t<u;t++){const a=e.util.indexToLoc(t,p,f).map((t,e)=>t+h[e]);I[e.util.locToIndex(a,y,g)]=c[t]}return{dataId:r.write(I,d,o.dtype),shape:d,dtype:o.dtype}}};function H(t){const{inputs:e,backend:a,attrs:n}=t,{x:r}=e,{shape:s}=n;return a.incRef(r.dataId),{dataId:r.dataId,shape:s,dtype:r.dtype}}const _={kernelName:e.Reshape,backendName:"cpu",kernelFunc:H},O={kernelName:e.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:n})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=a,l=n,d=e.util.getTypedArrayFromDType(r.dtype,e.util.sizeFromShape(r.shape)),[h,c,u,p]=r.shape,[f,m]=e.backend_util.getImageCenter(i,c,u),y=Math.sin(s),g=Math.cos(s),I=l.data.get(r.dataId).values;for(let t=0;t<h;t++){const e=t*u*c*p;for(let t=0;t<c;t++){const a=t*(u*p);for(let n=0;n<u;n++){const r=n*p;for(let s=0;s<p;s++){const i=[h,t,n,s],l=i[2],S=i[1];let b=(l-f)*g-(S-m)*y,k=(l-f)*y+(S-m)*g;b=Math.round(b+f),k=Math.round(k+m);let x=o;if("number"!=typeof o&&(x=3===s?255:o[s]),b>=0&&b<u&&k>=0&&k<c){x=I[e+k*(u*p)+b*p+s]}d[e+a+r+s]=x}}}}return{dataId:l.write(d,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function C(t){const{inputs:e,attrs:a,backend:r}=t,{x:s}=e,{perm:o}=a;n(s,"transpose");const i=s.shape.length,l=new Array(i);for(let t=0;t<l.length;t++)l[t]=s.shape[o[t]];const d=f(r.data.get(s.dataId).values,s.shape,s.dtype,o,l);return{dataId:r.write(d,l,s.dtype),shape:l,dtype:s.dtype}}const B={kernelName:e.Transpose,backendName:"cpu",kernelFunc:C};const E={kernelName:e.SpaceToBatchND,backendName:"cpu",kernelFunc:function(t){const{inputs:a,backend:r,attrs:s}=t,{x:o}=a,{blockShape:i,paddings:l}=s;n([o],"spaceToBatchND");const d=e.util.sizeFromShape(i),h=[[0,0]];h.push(...l);for(let t=1+i.length;t<o.shape.length;++t)h.push([0,0]);const c=W.kernelFunc({inputs:{x:o},backend:r,attrs:{paddings:h,constantValue:0}}),u=e.backend_util.getReshaped(c.shape,i,d,!1),p=e.backend_util.getPermuted(u.length,i.length,!1),f=e.backend_util.getReshapedPermuted(c.shape,i,d,!1),m=H({inputs:{x:c},backend:r,attrs:{shape:u}}),y=C({inputs:{x:m},backend:r,attrs:{perm:p}}),g=H({inputs:{x:y},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),g}},P={kernelName:e.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:a}=t,r=e;n(a,"square");const s=r.data.get(a.dataId).values,o=new Float32Array(s.length);for(let t=0;t<s.length;++t){const e=s[t];o[t]=e*e}return{dataId:r.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},R=k((t,e)=>{const a=t-e;return a*a}),q=b(e.SquaredDifference,R),L=[y,g,S,I,M,F,A,T,v,N,w,W,_,O,E,P,q,B];for(const t of L)e.registerKernel(t);t.MathBackendCPU=u,t.shared=m,t.version_cpu="2.4.0",Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-cpu.es2017.min.js.map
