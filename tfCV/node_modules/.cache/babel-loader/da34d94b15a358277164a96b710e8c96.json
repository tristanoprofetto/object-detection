{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  const output = buffer(convInfo.outShape, dtype);\n  const outputVals = output.values;\n  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  const outputColStrides = convInfo.outShape[3];\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    const outputBatchOffset = b * outputBatchStrides;\n    const inputBatchOffset = b * strides[0];\n\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        const xRMin = Math.max(0, xRCorner);\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          const xCMin = Math.max(0, xCCorner);\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let minMaxValue = initialValue;\n          let avgValue = 0;\n          let count = 0;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const xROffset = inputBatchOffset + xR * strides[1];\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const xCOffset = xROffset + xC * strides[2];\n              const pixel = xValues[xCOffset + d];\n\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n\n          const outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n  const maxPositions = buffer(convInfo.outShape, 'int32');\n  const strideHeight = convInfo.strideHeight;\n  const strideWidth = convInfo.strideWidth;\n  const dilationHeight = convInfo.dilationHeight;\n  const dilationWidth = convInfo.dilationWidth;\n  const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  const padTop = convInfo.padInfo.top;\n  const padLeft = convInfo.padInfo.left;\n  const xBuf = buffer(xShape, dtype, xValues);\n\n  for (let b = 0; b < convInfo.batchSize; ++b) {\n    for (let d = 0; d < convInfo.inChannels; ++d) {\n      for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n        const xRCorner = yR * strideHeight - padTop;\n        let xRMin = xRCorner;\n\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        } // const xRMin = Math.max(0, xRCorner);\n\n\n        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n\n        for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n          const xCCorner = yC * strideWidth - padLeft;\n          let xCMin = xCCorner;\n\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n\n          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          let maxValue = Number.NEGATIVE_INFINITY;\n          let maxPosition = -1;\n\n          for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            const wR = xR - xRCorner;\n\n            for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              const wC = xC - xCCorner;\n              const pixel = xBuf.get(b, xR, xC, d);\n\n              if (pixel > maxValue) {\n                maxValue = pixel;\n\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}","map":{"version":3,"sources":["../../src/utils/pool_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n    const outputColStrides = convInfo.outShape[3];\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        const outputBatchOffset = b * outputBatchStrides;\n        const inputBatchOffset = b * strides[0];\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    const xCMin = Math.max(0, xCCorner);\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let minMaxValue = initialValue;\n                    let avgValue = 0;\n                    let count = 0;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const xROffset = inputBatchOffset + xR * strides[1];\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const xCOffset = xROffset + xC * strides[2];\n                            const pixel = xValues[xCOffset + d];\n                            if ((poolType === 'max' && pixel > minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel;\n                                count++;\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    const outputOffset = outputRowOffset + yC * outputColStrides + d;\n                    outputVals[outputOffset] =\n                        poolType === 'avg' ? avgValue / count : minMaxValue;\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const xBuf = buffer(xShape, dtype, xValues);\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                let xRMin = xRCorner;\n                while (xRMin < 0) {\n                    xRMin += dilationHeight;\n                }\n                // const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    let xCMin = xCCorner;\n                    while (xCMin < 0) {\n                        xCMin += dilationWidth;\n                    }\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let maxValue = Number.NEGATIVE_INFINITY;\n                    let maxPosition = -1;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const wR = xR - xRCorner;\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const wC = xC - xCCorner;\n                            const pixel = xBuf.get(b, xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                if (flattenPositions) {\n                                    maxPosition = includeBatchInIndex ?\n                                        ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                                            convInfo.inChannels +\n                                            d :\n                                        (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                                }\n                                else {\n                                    maxPosition = wR * effectiveFilterWidth + wC;\n                                }\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, b, yR, yC, d);\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\n//# sourceMappingURL=pool_utils.js.map"]},"metadata":{},"sourceType":"module"}