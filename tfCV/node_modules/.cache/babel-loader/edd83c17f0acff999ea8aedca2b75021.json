{"ast":null,"code":"import { computeStrides } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  if (tensor.rank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + ` but the rank was ${tensor.rank}.`);\n  }\n\n  if (indices.rank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indices.rank}.`);\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + ` but the dtype was ${indices.dtype}.`);\n  }\n\n  if (indices.shape[indices.rank - 1] > tensor.rank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + `${indices.shape[indices.rank - 1]} vs. ${tensor.rank}`);\n  }\n\n  if (tensor.size === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  let nResult = 1;\n\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n  let sliceSize = 1;\n\n  for (let i = sliceRank; i < tensor.rank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize), 1].slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"sources":["../../src/ops/gather_nd_util.ts"],"names":[],"mappings":"AAiBA,SAAQ,cAAR,QAA6B,SAA7B;AAEA;;;;;;;;;AAQA,OAAM,SAAU,kBAAV,CACF,MADE,EACc,OADd,EAC6B;AACjC,MAAI,MAAM,CAAC,IAAP,GAAc,CAAlB,EAAqB;AACnB,UAAM,IAAI,KAAJ,CACF,4DACA,qBAAqB,MAAM,CAAC,IAAI,GAF9B,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,IAAR,GAAe,CAAnB,EAAsB;AACpB,UAAM,IAAI,KAAJ,CACF,8DACA,qBAAqB,OAAO,CAAC,IAAI,GAF/B,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,KAAkB,OAAtB,EAA+B;AAC7B,UAAM,IAAI,KAAJ,CACF,wDACA,sBAAsB,OAAO,CAAC,KAAK,GAFjC,CAAN;AAGD;;AACD,MAAI,OAAO,CAAC,KAAR,CAAc,OAAO,CAAC,IAAR,GAAe,CAA7B,IAAkC,MAAM,CAAC,IAA7C,EAAmD;AACjD,UAAM,IAAI,KAAJ,CACF,mEACA,GAAG,OAAO,CAAC,KAAR,CAAc,OAAO,CAAC,IAAR,GAAe,CAA7B,CAA+B,QAAQ,MAAM,CAAC,IAAI,EAFnD,CAAN;AAGD;;AAED,MAAI,MAAM,CAAC,IAAP,KAAgB,CAApB,EAAuB;AACrB,UAAM,IAAI,KAAJ,CACF,uDACA,iBAAiB,MAAM,CAAC,KAAK,GAF3B,CAAN;AAGD;;AAED,QAAM,YAAY,GAAG,OAAO,CAAC,KAA7B;AACA,QAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAA9B,CA7BiC,CA+BjC;AACA;;AACA,MAAI,OAAO,GAAG,CAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAb,GAAsB,CAA1C,EAA6C,EAAE,CAA/C,EAAkD;AAChD,IAAA,OAAO,IAAI,YAAY,CAAC,CAAD,CAAvB;AACD;;AAED,QAAM,UAAU,GAAG,MAAM,CAAC,KAA1B;AAEA,QAAM,WAAW,GAAG,YAAY,CAAC,KAAb,EAApB;AACA,EAAA,WAAW,CAAC,GAAZ;AAEA,MAAI,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAI,CAAC,GAAG,SAAb,EAAwB,CAAC,GAAG,MAAM,CAAC,IAAnC,EAAyC,EAAE,CAA3C,EAA8C;AAC5C,IAAA,SAAS,IAAI,UAAU,CAAC,CAAD,CAAvB;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,UAAU,CAAC,CAAD,CAA3B;AACD;;AAED,QAAM,OAAO,GACT,CAAC,GAAG,cAAc,CAAC,MAAM,CAAC,KAAR,CAAd,CAA6B,GAA7B,CAAiC,MAAM,IAAI,MAAM,GAAG,SAApD,CAAJ,EACC,CADD,EACI,KADJ,CACU,CADV,EACa,SADb,CADJ;AAIA,SAAO,CAAC,WAAD,EAAc,OAAd,EAAuB,SAAvB,EAAkC,OAAlC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { computeStrides } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    if (tensor.rank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensor.rank}.`);\n    }\n    if (indices.rank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indices.rank - 1] > tensor.rank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indices.rank - 1]} vs. ${tensor.rank}`);\n    }\n    if (tensor.size === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensor.rank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=gather_nd_util.js.map"]},"metadata":{},"sourceType":"module"}