{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\nimport { makeZerosTypedArray } from '../util';\nimport { tensor1d } from './tensor1d';\nimport { zeros } from './zeros';\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\n\nexport function range(start, stop, step = 1, dtype = 'float32') {\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  const forward = () => {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n\n    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n      return zeros([0], dtype);\n    }\n\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = makeZerosTypedArray(numElements, dtype);\n\n    if (stop < start && step === 1) {\n      // Auto adjust the step's sign if it hasn't been set\n      // (or was set to 1)\n      step = -1;\n    }\n\n    values[0] = start;\n\n    for (let i = 1; i < values.length; i++) {\n      values[i] = values[i - 1] + step;\n    }\n\n    return tensor1d(values, dtype);\n  };\n\n  const attrs = {\n    start,\n    stop,\n    step,\n    dtype\n  };\n  return ENGINE.runKernelFunc(forward, {}\n  /* inputs */\n  , null\n  /* grad */\n  , Range, attrs);\n}","map":{"version":3,"sources":["../../src/ops/range.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQ,MAAR,QAAkC,WAAlC;AACA,SAAQ,KAAR,QAAgC,iBAAhC;AAGA,SAAQ,mBAAR,QAAkC,SAAlC;AAEA,SAAQ,QAAR,QAAuB,YAAvB;AACA,SAAQ,KAAR,QAAoB,SAApB;AAEA;;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAU,KAAV,CACF,KADE,EACa,IADb,EAC2B,IAAI,GAAG,CADlC,EAEF,KAAA,GAA2B,SAFzB,EAEkC;AACtC,MAAI,IAAI,KAAK,CAAb,EAAgB;AACd,UAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,QAAM,OAAO,GAAwB,MAAK;AACxC,UAAM,aAAa,GAAG,KAAK,KAAK,IAAhC;AACA,UAAM,2BAA2B,GAAG,KAAK,GAAG,IAAR,IAAgB,IAAI,GAAG,CAA3D;AACA,UAAM,2BAA2B,GAAG,IAAI,GAAG,KAAP,IAAgB,IAAI,GAAG,CAA3D;;AAEA,QAAI,aAAa,IAAI,2BAAjB,IACA,2BADJ,EACiC;AAC/B,aAAO,KAAK,CAAC,CAAC,CAAD,CAAD,EAAM,KAAN,CAAZ;AACD;;AAED,UAAM,WAAW,GAAG,IAAI,CAAC,GAAL,CAAS,IAAI,CAAC,IAAL,CAAU,CAAC,IAAI,GAAG,KAAR,IAAiB,IAA3B,CAAT,CAApB;AACA,UAAM,MAAM,GAAG,mBAAmB,CAAC,WAAD,EAAc,KAAd,CAAlC;;AAEA,QAAI,IAAI,GAAG,KAAP,IAAgB,IAAI,KAAK,CAA7B,EAAgC;AAC9B;AACA;AACA,MAAA,IAAI,GAAG,CAAC,CAAR;AACD;;AAED,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,KAAZ;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,MAAA,MAAM,CAAC,CAAD,CAAN,GAAY,MAAM,CAAC,CAAC,GAAG,CAAL,CAAN,GAAgB,IAA5B;AACD;;AAED,WAAO,QAAQ,CAAC,MAAD,EAAS,KAAT,CAAf;AACD,GAzBD;;AA2BA,QAAM,KAAK,GAAe;AAAC,IAAA,KAAD;AAAQ,IAAA,IAAR;AAAc,IAAA,IAAd;AAAoB,IAAA;AAApB,GAA1B;AAEA,SAAO,MAAM,CAAC,aAAP,CACI,OADJ,EACa;AAAG;AADhB,IAC8B;AAAK;AADnC,IAC+C,KAD/C,EAEI,KAFJ,CAAP;AAGD","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\nimport { makeZerosTypedArray } from '../util';\nimport { tensor1d } from './tensor1d';\nimport { zeros } from './zeros';\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function range(start, stop, step = 1, dtype = 'float32') {\n    if (step === 0) {\n        throw new Error('Cannot have a step of zero');\n    }\n    const forward = () => {\n        const sameStartStop = start === stop;\n        const increasingRangeNegativeStep = start < stop && step < 0;\n        const decreasingRangePositiveStep = stop < start && step > 1;\n        if (sameStartStop || increasingRangeNegativeStep ||\n            decreasingRangePositiveStep) {\n            return zeros([0], dtype);\n        }\n        const numElements = Math.abs(Math.ceil((stop - start) / step));\n        const values = makeZerosTypedArray(numElements, dtype);\n        if (stop < start && step === 1) {\n            // Auto adjust the step's sign if it hasn't been set\n            // (or was set to 1)\n            step = -1;\n        }\n        values[0] = start;\n        for (let i = 1; i < values.length; i++) {\n            values[i] = values[i - 1] + step;\n        }\n        return tensor1d(values, dtype);\n    };\n    const attrs = { start, stop, step, dtype };\n    return ENGINE.runKernelFunc(forward, {} /* inputs */, null /* grad */, Range, attrs);\n}\n//# sourceMappingURL=range.js.map"]},"metadata":{},"sourceType":"module"}