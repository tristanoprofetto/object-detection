{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\n\nexport function getExecutionSubgraph(inputs, outputs, weightMap) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null; // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n\n  const seen = new Set();\n  const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n  const frontier = [...outputs];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n\n    if (isControlFlow(node) || isDynamicShape(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n\n    usedNodes.add(node.name); // Weights are dead end since we already have their values.\n\n    if (weightMap[node.name] != null) {\n      continue;\n    } // This node is a dead end since it's one of the user-provided inputs.\n\n\n    if (inputNodeNames.indexOf(node.name) !== -1) {\n      continue;\n    }\n\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\n\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const frontier = [];\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  inputNodes.forEach(input => {\n    if (usedNodes.has(input.name)) {\n      frontier.push(input);\n    }\n  });\n  graph.weights.forEach(weight => {\n    if (usedNodes.has(weight.name)) {\n      frontier.push(weight);\n    }\n  });\n  const seen = new Set();\n  const orderedNodes = [];\n\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    seen.add(node.name);\n\n    if (!weightMap[node.name]) {\n      orderedNodes.push(node);\n    }\n\n    node.children.forEach(child => {\n      if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every(input => seen.has(input.name))) {\n        frontier.push(child);\n      }\n    });\n  }\n\n  return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While'];\nconst DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'];\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}","map":{"version":3,"sources":["../../src/executor/model_analysis.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap) {\n    const usedNodes = new Set();\n    const missingInputs = [];\n    let dynamicNode = null;\n    let syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    const seen = new Set();\n    const inputNodeNames = Object.keys(inputs).map(name => parseNodeName(name)[0]);\n    const frontier = [...outputs];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(child => child.name)\n                    .filter(name => usedNodes.has(name));\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputNodeNames.indexOf(node.name) !== -1) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(input => {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n    const { usedNodes, inputs } = executionInfo;\n    const frontier = [];\n    const inputNodes = Object.keys(inputs)\n        .map(name => parseNodeName(name)[0])\n        .map(name => graph.nodes[name]);\n    inputNodes.forEach(input => {\n        if (usedNodes.has(input.name)) {\n            frontier.push(input);\n        }\n    });\n    graph.weights.forEach(weight => {\n        if (usedNodes.has(weight.name)) {\n            frontier.push(weight);\n        }\n    });\n    const seen = new Set();\n    const orderedNodes = [];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        seen.add(node.name);\n        if (!weightMap[node.name]) {\n            orderedNodes.push(node);\n        }\n        node.children.forEach(child => {\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\n                child.inputs.every(input => seen.has(input.name))) {\n                frontier.push(child);\n            }\n        });\n    }\n    return orderedNodes;\n}\nconst CONTROL_FLOW_OPS = [\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n    'StatelessWhile', 'if', 'While'\n];\nconst DYNAMIC_SHAPE_OPS = [\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n];\nexport function isControlFlow(node) {\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexport function isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\n//# sourceMappingURL=model_analysis.js.map"]},"metadata":{},"sourceType":"module"}