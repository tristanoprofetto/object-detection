{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Conv2DBackpropFilter } from '../kernel_names';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes the derivative of the filter of a 2D convolution.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\n * @param dy The dy image, of rank 4 or rank 3, of shape\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\n * @param filterShape The shape of the filter, length 4,\n *     [filterHeight, filterWidth, inDepth, outDepth].\n * @param strides The strides of the convolution: [strideHeight,\n * strideWidth].\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\n\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {\n  let x4D = x;\n\n  if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  }\n\n  let dy4D = dy;\n\n  if (dy4D.rank === 3) {\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n\n  util.assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` + `${x4D.shape}.`);\n  util.assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` + `${dy4D.shape}.`);\n  util.assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` + `${filterShape}.`);\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` + `match input depth in filter (${filterShape[2]}.`);\n  util.assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` + `match output depth for filter (${filterShape[3]}).`);\n\n  if (dimRoundingMode != null) {\n    util.assert(util.isInt(pad), () => `Error in conv2dDerFilter: pad must be an integer when using, ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const forward = backend => {\n    const dilations = 1;\n    const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n    const convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\n    return backend.conv2dDerFilter(x4D, dy4D, convInfo);\n  };\n\n  const inputs = {\n    x: x4D,\n    dy: dy4D\n  };\n  const attrs = {\n    strides,\n    pad,\n    dataFormat,\n    dimRoundingMode\n  };\n  return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\n}\n\nexport const conv2DBackpropFilter = op({\n  conv2DBackpropFilter_\n});","map":{"version":3,"sources":["../../src/ops/conv2d_backprop_filter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Conv2DBackpropFilter } from '../kernel_names';\nimport * as util from '../util';\nimport * as conv_util from './conv_util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Computes the derivative of the filter of a 2D convolution.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\n * @param dy The dy image, of rank 4 or rank 3, of shape\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\n * @param filterShape The shape of the filter, length 4,\n *     [filterHeight, filterWidth, inDepth, outDepth].\n * @param strides The strides of the convolution: [strideHeight,\n * strideWidth].\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. The\n *     rounding mode used when computing output dimensions if pad is a\n *     number. If none is provided, it will not round and error if the output\n *     is of fractional size.\n */\nfunction conv2DBackpropFilter_(x, dy, filterShape, strides, pad, dataFormat = 'NHWC', dimRoundingMode) {\n    let x4D = x;\n    if (x.rank === 3) {\n        x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n    }\n    let dy4D = dy;\n    if (dy4D.rank === 3) {\n        dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n    }\n    util.assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\n        `${x4D.shape}.`);\n    util.assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\n        `${dy4D.shape}.`);\n    util.assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\n        `${filterShape}.`);\n    const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n    const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n    util.assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +\n        `match input depth in filter (${filterShape[2]}.`);\n    util.assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +\n        `match output depth for filter (${filterShape[3]}).`);\n    if (dimRoundingMode != null) {\n        util.assert(util.isInt(pad), () => `Error in conv2dDerFilter: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    }\n    const forward = backend => {\n        const dilations = 1;\n        const $dataFormat = conv_util.convertConv2DDataFormat(dataFormat);\n        const convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);\n        return backend.conv2dDerFilter(x4D, dy4D, convInfo);\n    };\n    const inputs = { x: x4D, dy: dy4D };\n    const attrs = { strides, pad, dataFormat, dimRoundingMode };\n    return ENGINE.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);\n}\nexport const conv2DBackpropFilter = op({ conv2DBackpropFilter_ });\n//# sourceMappingURL=conv2d_backprop_filter.js.map"]},"metadata":{},"sourceType":"module"}