{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport { CLASSES } from './classes';\nconst BASE_PATH = 'https://storage.googleapis.com/tfjs-models/savedmodel/';\nexport { version } from './version';\nexport async function load(config = {}) {\n  if (tf == null) {\n    throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please ` + `also include @tensorflow/tfjs on the page before using this model.`);\n  }\n\n  const base = config.base || 'lite_mobilenet_v2';\n  const modelUrl = config.modelUrl;\n\n  if (['mobilenet_v1', 'mobilenet_v2', 'lite_mobilenet_v2'].indexOf(base) === -1) {\n    throw new Error(`ObjectDetection constructed with invalid base model ` + `${base}. Valid names are 'mobilenet_v1',` + ` 'mobilenet_v2' and 'lite_mobilenet_v2'.`);\n  }\n\n  const objectDetection = new ObjectDetection(base, modelUrl);\n  await objectDetection.load();\n  return objectDetection;\n}\nexport class ObjectDetection {\n  constructor(base, modelUrl) {\n    this.modelPath = modelUrl || `${BASE_PATH}${this.getPrefix(base)}/model.json`;\n  }\n\n  getPrefix(base) {\n    return base === 'lite_mobilenet_v2' ? `ssd${base}` : `ssd_${base}`;\n  }\n\n  async load() {\n    this.model = await tfconv.loadGraphModel(this.modelPath);\n    const zeroTensor = tf.zeros([1, 300, 300, 3], 'int32'); // Warmup the model.\n\n    const result = await this.model.executeAsync(zeroTensor);\n    await Promise.all(result.map(t => t.data()));\n    result.map(t => t.dispose());\n    zeroTensor.dispose();\n  }\n  /**\n   * Infers through the model.\n   *\n   * @param img The image to classify. Can be a tensor or a DOM element image,\n   * video, or canvas.\n   * @param maxNumBoxes The maximum number of bounding boxes of detected\n   * objects. There can be multiple objects of the same class, but at different\n   * locations. Defaults to 20.\n   * @param minScore The minimum score of the returned bounding boxes\n   * of detected objects. Value between 0 and 1. Defaults to 0.5.\n   */\n\n\n  async infer(img, maxNumBoxes, minScore) {\n    const batched = tf.tidy(() => {\n      if (!(img instanceof tf.Tensor)) {\n        img = tf.browser.fromPixels(img);\n      } // Reshape to a single-element batch so we can pass it to executeAsync.\n\n\n      return img.expandDims(0);\n    });\n    const height = batched.shape[1];\n    const width = batched.shape[2]; // model returns two tensors:\n    // 1. box classification score with shape of [1, 1917, 90]\n    // 2. box location with shape of [1, 1917, 1, 4]\n    // where 1917 is the number of box detectors, 90 is the number of classes.\n    // and 4 is the four coordinates of the box.\n\n    const result = await this.model.executeAsync(batched);\n    const scores = result[0].dataSync();\n    const boxes = result[1].dataSync(); // clean the webgl tensors\n\n    batched.dispose();\n    tf.dispose(result);\n    const [maxScores, classes] = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]);\n    const prevBackend = tf.getBackend(); // run post process in cpu\n\n    tf.setBackend('cpu');\n    const indexTensor = tf.tidy(() => {\n      const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n      return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, minScore, minScore);\n    });\n    const indexes = indexTensor.dataSync();\n    indexTensor.dispose(); // restore previous backend\n\n    tf.setBackend(prevBackend);\n    return this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);\n  }\n\n  buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n    const count = indexes.length;\n    const objects = [];\n\n    for (let i = 0; i < count; i++) {\n      const bbox = [];\n\n      for (let j = 0; j < 4; j++) {\n        bbox[j] = boxes[indexes[i] * 4 + j];\n      }\n\n      const minY = bbox[0] * height;\n      const minX = bbox[1] * width;\n      const maxY = bbox[2] * height;\n      const maxX = bbox[3] * width;\n      bbox[0] = minX;\n      bbox[1] = minY;\n      bbox[2] = maxX - minX;\n      bbox[3] = maxY - minY;\n      objects.push({\n        bbox: bbox,\n        class: CLASSES[classes[indexes[i]] + 1].displayName,\n        score: scores[indexes[i]]\n      });\n    }\n\n    return objects;\n  }\n\n  calculateMaxScores(scores, numBoxes, numClasses) {\n    const maxes = [];\n    const classes = [];\n\n    for (let i = 0; i < numBoxes; i++) {\n      let max = Number.MIN_VALUE;\n      let index = -1;\n\n      for (let j = 0; j < numClasses; j++) {\n        if (scores[i * numClasses + j] > max) {\n          max = scores[i * numClasses + j];\n          index = j;\n        }\n      }\n\n      maxes[i] = max;\n      classes[i] = index;\n    }\n\n    return [maxes, classes];\n  }\n  /**\n   * Detect objects for an image returning a list of bounding boxes with\n   * assocated class and score.\n   *\n   * @param img The image to detect objects from. Can be a tensor or a DOM\n   *     element image, video, or canvas.\n   * @param maxNumBoxes The maximum number of bounding boxes of detected\n   * objects. There can be multiple objects of the same class, but at different\n   * locations. Defaults to 20.\n   * @param minScore The minimum score of the returned bounding boxes\n   * of detected objects. Value between 0 and 1. Defaults to 0.5.\n   */\n\n\n  async detect(img, maxNumBoxes = 20, minScore = 0.5) {\n    return this.infer(img, maxNumBoxes, minScore);\n  }\n  /**\n   * Dispose the tensors allocated by the model. You should call this when you\n   * are done with the model.\n   */\n\n\n  dispose() {\n    if (this.model != null) {\n      this.model.dispose();\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/tprofetto/Documents/tensorflow/js/ReactComputerVisionTemplate/node_modules/@tensorflow-models/coco-ssd/dist/index.js"],"names":["tfconv","tf","CLASSES","BASE_PATH","version","load","config","Error","base","modelUrl","indexOf","objectDetection","ObjectDetection","constructor","modelPath","getPrefix","model","loadGraphModel","zeroTensor","zeros","result","executeAsync","Promise","all","map","t","data","dispose","infer","img","maxNumBoxes","minScore","batched","tidy","Tensor","browser","fromPixels","expandDims","height","shape","width","scores","dataSync","boxes","maxScores","classes","calculateMaxScores","prevBackend","getBackend","setBackend","indexTensor","boxes2","tensor2d","image","nonMaxSuppression","indexes","buildDetectedObjects","count","length","objects","i","bbox","j","minY","minX","maxY","maxX","push","class","displayName","score","numBoxes","numClasses","maxes","max","Number","MIN_VALUE","index","detect"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport { CLASSES } from './classes';\nconst BASE_PATH = 'https://storage.googleapis.com/tfjs-models/savedmodel/';\nexport { version } from './version';\nexport async function load(config = {}) {\n    if (tf == null) {\n        throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n            `also include @tensorflow/tfjs on the page before using this model.`);\n    }\n    const base = config.base || 'lite_mobilenet_v2';\n    const modelUrl = config.modelUrl;\n    if (['mobilenet_v1', 'mobilenet_v2', 'lite_mobilenet_v2'].indexOf(base) ===\n        -1) {\n        throw new Error(`ObjectDetection constructed with invalid base model ` +\n            `${base}. Valid names are 'mobilenet_v1',` +\n            ` 'mobilenet_v2' and 'lite_mobilenet_v2'.`);\n    }\n    const objectDetection = new ObjectDetection(base, modelUrl);\n    await objectDetection.load();\n    return objectDetection;\n}\nexport class ObjectDetection {\n    constructor(base, modelUrl) {\n        this.modelPath =\n            modelUrl || `${BASE_PATH}${this.getPrefix(base)}/model.json`;\n    }\n    getPrefix(base) {\n        return base === 'lite_mobilenet_v2' ? `ssd${base}` : `ssd_${base}`;\n    }\n    async load() {\n        this.model = await tfconv.loadGraphModel(this.modelPath);\n        const zeroTensor = tf.zeros([1, 300, 300, 3], 'int32');\n        // Warmup the model.\n        const result = await this.model.executeAsync(zeroTensor);\n        await Promise.all(result.map(t => t.data()));\n        result.map(t => t.dispose());\n        zeroTensor.dispose();\n    }\n    /**\n     * Infers through the model.\n     *\n     * @param img The image to classify. Can be a tensor or a DOM element image,\n     * video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n    async infer(img, maxNumBoxes, minScore) {\n        const batched = tf.tidy(() => {\n            if (!(img instanceof tf.Tensor)) {\n                img = tf.browser.fromPixels(img);\n            }\n            // Reshape to a single-element batch so we can pass it to executeAsync.\n            return img.expandDims(0);\n        });\n        const height = batched.shape[1];\n        const width = batched.shape[2];\n        // model returns two tensors:\n        // 1. box classification score with shape of [1, 1917, 90]\n        // 2. box location with shape of [1, 1917, 1, 4]\n        // where 1917 is the number of box detectors, 90 is the number of classes.\n        // and 4 is the four coordinates of the box.\n        const result = await this.model.executeAsync(batched);\n        const scores = result[0].dataSync();\n        const boxes = result[1].dataSync();\n        // clean the webgl tensors\n        batched.dispose();\n        tf.dispose(result);\n        const [maxScores, classes] = this.calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]);\n        const prevBackend = tf.getBackend();\n        // run post process in cpu\n        tf.setBackend('cpu');\n        const indexTensor = tf.tidy(() => {\n            const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n            return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes, minScore, minScore);\n        });\n        const indexes = indexTensor.dataSync();\n        indexTensor.dispose();\n        // restore previous backend\n        tf.setBackend(prevBackend);\n        return this.buildDetectedObjects(width, height, boxes, maxScores, indexes, classes);\n    }\n    buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n        const count = indexes.length;\n        const objects = [];\n        for (let i = 0; i < count; i++) {\n            const bbox = [];\n            for (let j = 0; j < 4; j++) {\n                bbox[j] = boxes[indexes[i] * 4 + j];\n            }\n            const minY = bbox[0] * height;\n            const minX = bbox[1] * width;\n            const maxY = bbox[2] * height;\n            const maxX = bbox[3] * width;\n            bbox[0] = minX;\n            bbox[1] = minY;\n            bbox[2] = maxX - minX;\n            bbox[3] = maxY - minY;\n            objects.push({\n                bbox: bbox,\n                class: CLASSES[classes[indexes[i]] + 1].displayName,\n                score: scores[indexes[i]]\n            });\n        }\n        return objects;\n    }\n    calculateMaxScores(scores, numBoxes, numClasses) {\n        const maxes = [];\n        const classes = [];\n        for (let i = 0; i < numBoxes; i++) {\n            let max = Number.MIN_VALUE;\n            let index = -1;\n            for (let j = 0; j < numClasses; j++) {\n                if (scores[i * numClasses + j] > max) {\n                    max = scores[i * numClasses + j];\n                    index = j;\n                }\n            }\n            maxes[i] = max;\n            classes[i] = index;\n        }\n        return [maxes, classes];\n    }\n    /**\n     * Detect objects for an image returning a list of bounding boxes with\n     * assocated class and score.\n     *\n     * @param img The image to detect objects from. Can be a tensor or a DOM\n     *     element image, video, or canvas.\n     * @param maxNumBoxes The maximum number of bounding boxes of detected\n     * objects. There can be multiple objects of the same class, but at different\n     * locations. Defaults to 20.\n     * @param minScore The minimum score of the returned bounding boxes\n     * of detected objects. Value between 0 and 1. Defaults to 0.5.\n     */\n    async detect(img, maxNumBoxes = 20, minScore = 0.5) {\n        return this.infer(img, maxNumBoxes, minScore);\n    }\n    /**\n     * Dispose the tensors allocated by the model. You should call this when you\n     * are done with the model.\n     */\n    dispose() {\n        if (this.model != null) {\n            this.model.dispose();\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}